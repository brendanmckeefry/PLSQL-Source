create or replace PACKAGE BODY              FT_PK_BI
AS

  cVersionControlNo   VARCHAR2(12) := '1.0.9'; -- Current Version Number

-- Added SALES_PACKS_MOVE to DGPDetails TV 2Nov16  
-- Changed TV 10Oct16 As per MI/AD comments on DR document

 CURSOR LASTUSED_CUR(TABLEFLAG_IN NUMBER, SYSTEM_IN VARCHAR2)    
    IS
    /* restrict the DGPHEADER to only give 2 per run so as to give all the other procedures a shot at running in each loop */ 
    SELECT 	UNIQUERECNO, UNIQUERECNO2, TABLEFLAG, OPERATIONTYPE, LASTUSED
    FROM HH_TABLE_LASTUSED
    WHERE TABLEFLAG = TABLEFLAG_IN
    AND (   (C_HH = SYSTEM_IN AND WAITINGFORHH = 1)
         OR (C_BI = SYSTEM_IN AND WAITINGFORBI = 1)
        ) 
    AND (   (TABLEFLAG_IN <> C_DGPHEADER)
         OR (rownum <= 2) 
        ) 
    ORDER BY 1, 2;
  
  LASTUSED_REC       LASTUSED_CUR%ROWTYPE;  
  
  /* This cursor is used to repopulate the Lookups table on the rare occasion it changes
     these are the only records needed to be transferred, so the trigger will only 
     fire when when one changes and then the whole lot are resent */
  /* Changed TV 17May16 to include Credit reasons which are not held in lookups in FT, but are in Handheld
  CURSOR LOOKUPS_CUR    
    IS
    SELECT 	* 
    FROM LOOKUPS
    WHERE  (lkuptable = 'ACCCLASS' and LKUPFIELDNAME = 'CLAACCCSTSUP' and LKUPNO > 0)
    OR    (lkuptable = 'ACCCAT' and LKUPFIELDNAME = 'CLACLASS' and LKUPNO > 0)
    OR    (lkuptable = 'CASHTIKPAY' and LKUPFIELDNAME = 'CSHTIKPAYTYPE' and LKUPNO IN(1,2,3,5))
    ORDER BY 1, 2;
    Changed 10Oct16 to add PriceByType (PUR_LOTITE)
   */
	CURSOR LOOKUPS_CUR    
    IS
    (SELECT LKUPTABLE, LKUPFIELDNAME, LKUPNO, LKUPDESC FROM LOOKUPS
    WHERE  (lkuptable = 'ACCCLASS' and LKUPFIELDNAME = 'CLAACCCSTSUP' and LKUPNO > 0)
    OR    (lkuptable = 'ACCCAT' and LKUPFIELDNAME = 'CLACLASS' and LKUPNO IN (5,6,8,11))
    OR    (lkuptable = 'PUR_LOTITE' and LKUPFIELDNAME = 'PRCBYTYP')
    OR    (lkuptable = 'CASHTIKPAY' and LKUPFIELDNAME = 'CSHTIKPAYTYPE' and LKUPNO IN(1,2,3,5)))
    union
    (select 'CDSSTKADJ' as LKUPTABLE, 'CDSADJSTOCK' as LKUPFIELDNAME, CDSREFNO as LKUPNO, CDSDESCRIPTION as LKUPDESC  from CDSTKADJ
    WHERE CDSADJUSTSTK = 1 and CDSREFNO > 0
    )
    union
    (select 'CDSSTKADJ' as LKUPTABLE, 'CDSNOTADJSTOCK' as LKUPFIELDNAME, CDSREFNO as LKUPNO, CDSDESCRIPTION as LKUPDESC  from CDSTKADJ
    WHERE CDSADJUSTSTK = 0 and CDSREFNO > 0
    )
    ORDER BY 1, 2;	
	
    LOOKUPS_REC       LOOKUPS_CUR%ROWTYPE;  
  

  FUNCTION CURRENTVERSION(IN_BODYORSPEC IN INTEGER ) RETURN VARCHAR2
  IS
  BEGIN
    IF  IN_BODYORSPEC = CONST.C_SPEC THEN
         RETURN cSpecVersionControlNo;
    ELSE  
        RETURN cVersionControlNo;
    END IF;        
        
  END CURRENTVERSION;
 
  PROCEDURE INSERT_LASTUSED(IN_RECNO1 INTEGER, IN_RECNO2 INTEGER, IN_TABLEFLAG INTEGER, IN_OPERATIONTYPE VARCHAR2 ) AS
  BEGIN
    -- Called from triggers on tables that are needed in the Hand Held module
    -- This populates HH_TABLE_LASTUSED with keys of changed records
    -- BSDL14496 TPUK TV 22Jul15
    -- Changed TV 15Nov16 to only write records for BI processing
    MERGE INTO HH_TABLE_LASTUSED HH_LU  
    USING (SELECT IN_RECNO1 UNIQUERECNO , IN_RECNO2 UNIQUERECNO2, IN_TABLEFLAG TABLEFLAG, IN_OPERATIONTYPE OPERATIONTYPE,  SYSDATE LASTUSED FROM DUAL) TMPTAB
    ON (TMPTAB.UNIQUERECNO = HH_LU.UNIQUERECNO
        AND TMPTAB.UNIQUERECNO2 = HH_LU.UNIQUERECNO2
	      AND TMPTAB.TABLEFLAG = HH_LU.TABLEFLAG)
    WHEN MATCHED THEN 
        UPDATE SET HH_LU.OPERATIONTYPE = TMPTAB.OPERATIONTYPE, HH_LU.LASTUSED = TMPTAB.LASTUSED, HH_LU.WAITINGFORHH = 0,  HH_LU.WAITINGFORBI = DEFAULT
    WHEN NOT MATCHED THEN
        INSERT(HH_LU.UNIQUERECNO, HH_LU.UNIQUERECNO2, HH_LU.TABLEFLAG, HH_LU.OPERATIONTYPE, HH_LU.LASTUSED, HH_LU.WAITINGFORHH)
	      VALUES(TMPTAB.UNIQUERECNO, TMPTAB.UNIQUERECNO2, TMPTAB.TABLEFLAG, TMPTAB.OPERATIONTYPE, TMPTAB.LASTUSED, 0);
   EXCEPTION
    WHEN OTHERS THEN
      FT_PK_ERRORS.LOG_AND_CONTINUE;
  END INSERT_LASTUSED;

  /*  THIS PROCEDURE CALLS ALL THE OTHER PROCESS_***** PROCEDURES AND TAKES CHANGED RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO THE TRANSFER TABLE  
      This needs to be in this order because of referential integrity on the tables*/
  PROCEDURE PROCESS_ALL IS
  BEGIN
    /*(17)*/ PROCESS_DLVTYPE();
    /*(14)*/ PROCESS_ACCCLASS();
     /*(5)*/ PROCESS_SALOFFNO();
    /*(15)*/ PROCESS_ACCTOSALOFF();
     /*(6)*/ PROCESS_DEPARTMENTS();
     /*(7)*/ PROCESS_DPTTOSALOFFNO();
     /*(8)*/ PROCESS_SMN();
    /*(10)*/ PROCESS_DEPARTMENTSTOSMN();
     /*(3)*/ PROCESS_LOGONS();
     /*(4)*/ PROCESS_LOGTOSALOFF();
     /*(9)*/ PROCESS_SMNTOLOGON();
    /*(11)*/ PROCESS_SOFTOSTCLOC();
     /*(2)*/ PROCESS_PRDALLDESCS();
     /*(1)*/ PROCESS_PRDRECS();   
    /*(12)*/ PROCESS_PRDRECTOSO();
    /*(18)*/ PROCESS_LOOKUPS();
    
    /* BI specific procedures */
	PROCESS_ACCCURRDESC();      
    PROCESS_CHGTYP();           
    PROCESS_COUNTRY();          
    PROCESS_CSTANDES();
    PROCESS_CSTANGRP();         
	PROCESS_CSTANREC();          
    PROCESS_FIXEDROUTES();       
    PROCESS_HOFCST();            
    PROCESS_PRDGROUPCAT();      
    PROCESS_PRDGROUPCATREC();   
    PROCESS_PRDGROUPGRP();      
    PROCESS_PRDGROUPGRPREC();   
	PROCESS_DOCDISTCONTACTS();
	PROCESS_DGPHEADER();
 	
        
    /* This gets rid of records not needed by BI but needed by HH */ 
	 	PROCESS_NOT_NEEDED_FILES(C_VATRATES, C_BI); 
	 	PROCESS_NOT_NEEDED_FILES(C_ACCCAT, C_BI); 
	 	PROCESS_NOT_NEEDED_FILES(C_ALLOCATE, C_BI); 
	 	PROCESS_NOT_NEEDED_FILES(C_PURORD, C_BI); 
	 	PROCESS_NOT_NEEDED_FILES(C_LOTHED, C_BI); 
	 	PROCESS_NOT_NEEDED_FILES(C_LOTITE, C_BI); 
	 	PROCESS_NOT_NEEDED_FILES(C_ORDERS, C_BI); 
	 	PROCESS_NOT_NEEDED_FILES(C_DELHED, C_BI); 
	 	PROCESS_NOT_NEEDED_FILES(C_DELDET, C_BI); 
	 	PROCESS_NOT_NEEDED_FILES(C_DELPRICE, C_BI); 
	 	PROCESS_NOT_NEEDED_FILES(C_DELTOALL, C_BI); 
	 	PROCESS_NOT_NEEDED_FILES(C_TKTBK, C_BI); 
	 	PROCESS_NOT_NEEDED_FILES(C_TKTNT, C_BI); 
	 	PROCESS_NOT_NEEDED_FILES(C_POBK, C_BI); 
	 	PROCESS_NOT_NEEDED_FILES(C_PONT, C_BI); 
	 	PROCESS_NOT_NEEDED_FILES(C_SIGNATURE, C_BI); 
	 	PROCESS_NOT_NEEDED_FILES(C_HH_PAYMENTS, C_BI); 
	 	PROCESS_NOT_NEEDED_FILES(C_HH_GUID, C_BI); 
	
  END PROCESS_ALL; 
  
  /* THIS PROCEDURE TAKES PRDREC RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_PRDREC
     Amended for BI TV 4Aug16  */
  PROCEDURE PROCESS_PRDRECS AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_PRDREC, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_PRDREC BI  
              USING 
              (SELECT PRCPRDNO, PRCREF1, PRCREF2,PRCREF3,PRCREF4,PRCREF5,PRCREF6,TRIM(PRCDESCRIPTION) as PRCDESCRIPTION,PRCVATCODE,PRCPRDREF,ACTIVE,
   			          INNERQTY, PRCBOXQTY, PRCWEIGHT, PRCGRSWEIGHT, PACKWASTELISTTYPEID, sysdate as LASTTOUCHEDDATE FROM PRDREC
                  WHERE PRCPRDNO = LASTUSED_REC.UNIQUERECNO) 
                  TMPTAB
              ON (TMPTAB.PRCPRDNO = BI.PRCPRDNO)
              WHEN MATCHED THEN 
                  UPDATE SET  BI.PRCREF1 = TMPTAB.PRCREF1, 
                              BI.PRCREF2 = TMPTAB.PRCREF2, 
                              BI.PRCREF3 = TMPTAB.PRCREF3, 
                              BI.PRCREF4 = TMPTAB.PRCREF4,
                              BI.PRCREF5 = TMPTAB.PRCREF5, 
                              BI.PRCREF6 = TMPTAB.PRCREF6, 
                              BI.PRCDESCRIPTION = TMPTAB.PRCDESCRIPTION, 
                              BI.PRCVATCODE = TMPTAB.PRCVATCODE, 
                              BI.PRCPRDREF = TMPTAB.PRCPRDREF, 
                              BI.ACTIVE = TMPTAB.ACTIVE,
							  BI.INNERQTY = TMPTAB.INNERQTY,
							  BI.PRCBOXQTY = TMPTAB.PRCBOXQTY,
							  BI.PRCWEIGHT = TMPTAB.PRCWEIGHT,
							  BI.PRCGRSWEIGHT = TMPTAB.PRCGRSWEIGHT,
							  BI.PACKWASTELISTTYPEID = TMPTAB.PACKWASTELISTTYPEID,
							  BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
              WHEN NOT MATCHED THEN
                  INSERT(BI.PRCPRDNO, BI.PRCREF1, BI.PRCREF2, BI.PRCREF3, BI.PRCREF4, BI.PRCREF5, BI.PRCREF6, BI.PRCDESCRIPTION, BI.PRCVATCODE, BI.PRCPRDREF, BI.ACTIVE,
				         BI.INNERQTY, BI.PRCBOXQTY, BI.PRCWEIGHT, BI.PRCGRSWEIGHT, BI.PACKWASTELISTTYPEID, BI.LASTTOUCHEDDATE)
                  VALUES(TMPTAB.PRCPRDNO, TMPTAB.PRCREF1, TMPTAB.PRCREF2, TMPTAB.PRCREF3, TMPTAB.PRCREF4, TMPTAB.PRCREF5, TMPTAB.PRCREF6, TMPTAB.PRCDESCRIPTION,
 				         TMPTAB.PRCVATCODE, TMPTAB.PRCPRDREF, TMPTAB.ACTIVE,
						 TMPTAB.INNERQTY, TMPTAB.PRCBOXQTY, TMPTAB.PRCWEIGHT, TMPTAB.PRCGRSWEIGHT, TMPTAB.PACKWASTELISTTYPEID, TMPTAB.LASTTOUCHEDDATE);
              END;
            END IF;
                  
              -- THIS SHOULDNEVER HAPPEN AS A PRDPREC IS NEVER DELETED BUT WE'LL STICK IT IN 
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_PRDREC WHERE PRCPRDNO = LASTUSED_REC.UNIQUERECNO;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            
            -- SEND ALL THE PRDRECTOSO RECORDS 
            REFLAG_PRDRECTOSO_FORPRDREC(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.OPERATIONTYPE);
            
			COMMIT;
			
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_PRDRECS;
     
  /* THIS PROCEDURE TAKES PRDALLDESCS RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_PRDALLDESCS 
     Amended for BI TV 4Aug16*/
  PROCEDURE PROCESS_PRDALLDESCS AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_PRDALLDESCS, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_PRDALLDESCS BI  
              USING 
              (SELECT ALLPREFNO, ALLPLEVNO, ALLPDESC, ALLPCODE, NVL(ACTIVE,0) AS ACTIVE, NVL(UNDEFINED,0) as UNDEFINED, sysdate as LASTTOUCHEDDATE  
                  FROM PRDALLDESCS
                  WHERE ALLPREFNO = LASTUSED_REC.UNIQUERECNO) 
                  TMPTAB
              ON (TMPTAB.ALLPREFNO = BI.ALLPREFNO)
              WHEN MATCHED THEN 
                  UPDATE SET  BI.ALLPLEVNO = TMPTAB.ALLPLEVNO, 
                              BI.ALLPDESC = TMPTAB.ALLPDESC, 
                              BI.ALLPCODE = TMPTAB.ALLPCODE,
                              BI.ACTIVE = TMPTAB.ACTIVE,
                              BI.UNDEFINED = TMPTAB.UNDEFINED,
							                BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
              WHEN NOT MATCHED THEN
                  INSERT(BI.ALLPREFNO, BI.ALLPLEVNO, BI.ALLPDESC, BI.ALLPCODE,  BI.ACTIVE, BI.UNDEFINED, BI.LASTTOUCHEDDATE )
                  VALUES(TMPTAB.ALLPREFNO, TMPTAB.ALLPLEVNO, TMPTAB.ALLPDESC, TMPTAB.ALLPCODE,  TMPTAB.ACTIVE, TMPTAB.UNDEFINED, TMPTAB.LASTTOUCHEDDATE);
              END;
            END IF;
                  
              -- THIS SHOULD NEVER HAPPEN AS A PRDALLDESCS IS NEVER DELETED BUT WE'LL STICK IT IN 
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_PRDALLDESCS WHERE ALLPREFNO = LASTUSED_REC.UNIQUERECNO;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);

            COMMIT;           
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_PRDALLDESCS;
  
  /* THIS PROCEDURE TAKES PRDRECTOSO RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_PRDRECTOSO
     Amended for BI TV 4Aug16  */
  PROCEDURE PROCESS_PRDRECTOSO AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_PRDRECTOSO, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_PRDRECTOSO BI  
              USING 
              (
              SELECT PRDRECTOSO.SALOFFNO, PRDRECTOSO.PRCPRDNO, PRDRECTOSO.SOSHORTCODE,
              TRIM(SHORTCODEDEFAULT.SHORTCODEDESCRIPTION) AS SHORTCODEDESCRIPTION ,
              NVL(PRDREC.PRCSALBYBOX,0) as PRCSALBYBOX, NVL(PRDREC.PRCSALBYEACH,0) as PRCSALBYEACH, NVL(PRDREC.PRCSALBYINNER,0) as PRCSALBYINNER, NVL(PRDREC.PRCSALBYWGT,0) as PRCSALBYWGT, 
              PRDREC.PRCWEIGHT, PRDREC.INNERQTY, PRDREC.PRCBOXQTY, NVL(PRDREC.DEFAULTPRD,0) as DEFAULTPRD, NULL VATRECNO,
			  sysdate as LASTTOUCHEDDATE
              FROM PRDRECTOSO, SHORTCODEDEFAULT, PRDREC
              WHERE PRDRECTOSO.SOSHORTCODE = SHORTCODEDEFAULT.SHORTCODE(+)
              AND   PRDRECTOSO.SALOFFNO = SHORTCODEDEFAULT.SALESOFFICE(+)
              AND   PRDRECTOSO.PRCPRDNO = PRDREC.PRCPRDNO 
              AND   PRDRECTOSO.SALOFFNO   = LASTUSED_REC.UNIQUERECNO
              AND   PRDRECTOSO.PRCPRDNO = LASTUSED_REC.UNIQUERECNO2
              ) 
                  TMPTAB
              ON (
                TMPTAB.SALOFFNO = BI.SALOFFNO
                AND TMPTAB.PRCPRDNO = BI.PRCPRDNO              
              )
              WHEN MATCHED THEN 
                  UPDATE SET  BI.SOSHORTCODE = TMPTAB.SOSHORTCODE, 
                              BI.SHORTCODEDESCRIPTION = TMPTAB.SHORTCODEDESCRIPTION, 
                              BI.PRCSALBYBOX = TMPTAB.PRCSALBYBOX,
                              BI.PRCSALBYEACH = TMPTAB.PRCSALBYEACH,
                              BI.PRCSALBYINNER = TMPTAB.PRCSALBYINNER,
                              BI.PRCSALBYWGT = TMPTAB.PRCSALBYWGT,
                              BI.INNERQTY = TMPTAB.INNERQTY,
                              BI.PRCBOXQTY = TMPTAB.PRCBOXQTY,
                              BI.DEFAULTPRD = TMPTAB.DEFAULTPRD,
                              BI.VATRECNO = TMPTAB.VATRECNO,
							  BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
              WHEN NOT MATCHED THEN
                  INSERT(BI.SALOFFNO, BI.PRCPRDNO, BI.SOSHORTCODE, BI.SHORTCODEDESCRIPTION, BI.PRCSALBYBOX, BI.PRCSALBYEACH, BI.PRCSALBYINNER, BI.PRCSALBYWGT, 
                          BI.PRCWEIGHT, BI.INNERQTY, BI.PRCBOXQTY, BI.DEFAULTPRD, BI.VATRECNO, BI.LASTTOUCHEDDATE)
                  VALUES(TMPTAB.SALOFFNO, TMPTAB.PRCPRDNO, TMPTAB.SOSHORTCODE, TMPTAB.SHORTCODEDESCRIPTION, TMPTAB.PRCSALBYBOX, TMPTAB.PRCSALBYEACH, TMPTAB.PRCSALBYINNER, TMPTAB.PRCSALBYWGT, 
                          TMPTAB.PRCWEIGHT, TMPTAB.INNERQTY, TMPTAB.PRCBOXQTY, TMPTAB.DEFAULTPRD, TMPTAB.VATRECNO, TMPTAB.LASTTOUCHEDDATE  );
              END;
            END IF;
                  
              -- THIS SHOULD NEVER HAPPEN AS A PRDALLDESCS IS NEVER DELETED BUT WE'LL STICK IT IN 
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_PRDRECTOSO WHERE SALOFFNO = LASTUSED_REC.UNIQUERECNO
              AND   PRCPRDNO = LASTUSED_REC.UNIQUERECNO2
              ;                                       
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);            
            COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_PRDRECTOSO;
  
  /* THIS PROCEDURE TAKES LOGONS RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_LOGONS
     Amended for BI TV  4Aug16 */
  PROCEDURE PROCESS_LOGONS AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_LOGONS, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_LOGONS BI  
              USING 
              (SELECT LOGONNO, LOGONNAME,  TRIM(USERNAME) AS USERNAME, sysdate as LASTTOUCHEDDATE  FROM LOGONS
                  WHERE LOGONNO = LASTUSED_REC.UNIQUERECNO
                  --AND  = LASTUSED_REC.UNIQUERECNO2
                  ) 
                  TMPTAB
              ON (TMPTAB.LOGONNO = BI.LOGONNO)
              WHEN MATCHED THEN 
                  UPDATE SET  BI.LOGONNAME = TMPTAB.LOGONNAME, 
                              BI.USERNAME = TMPTAB.USERNAME,
							  BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
              WHEN NOT MATCHED THEN
                  INSERT(BI.LOGONNO, BI.LOGONNAME,  BI.USERNAME, BI.LASTTOUCHEDDATE)
                  VALUES(TMPTAB.LOGONNO, TMPTAB.LOGONNAME,  TMPTAB.USERNAME, TMPTAB.LASTTOUCHEDDATE);
              END;
            END IF;
                  
              -- THIS SHOULD NEVER HAPPEN AS A PRDALLDESCS IS NEVER DELETED BUT WE'LL STICK IT IN 
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_LOGONS WHERE LOGONNO = LASTUSED_REC.UNIQUERECNO
              --AND    = LASTUSED_REC.UNIQUERECNO2              
              ;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);            
            COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_LOGONS ;

  
  /* This procedure is called to cleardown all records in HH_TABLE_LASTUSED where the table is not transferred, hence the records will
     otherwise hang around for ever 
	 TV 5Aug16 */  
  PROCEDURE PROCESS_NOT_NEEDED_FILES(IN_TABLEFLAG NUMBER, IN_SYSTEMTYPE VARCHAR2) AS
  BEGIN
    
    OPEN LASTUSED_CUR(IN_TABLEFLAG, IN_SYSTEMTYPE);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
         DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, IN_SYSTEMTYPE);            
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_NOT_NEEDED_FILES;

  
  
  /* THIS PROCEDURE TAKES LOGTOSALOFF RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_LOGTOSALOFF */
  PROCEDURE PROCESS_LOGTOSALOFF AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_LOGTOSALOFF, C_BI );
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              INSERT INTO BI_LOGTOSALOFF(LOGONNO, SALOFFNO, LASTTOUCHEDDATE)
              (SELECT LOGONNO, SALOFFNO, sysdate as LASTTOUCHEDDATE FROM LOGTOSALOFF
                WHERE LOGONNO = LASTUSED_REC.UNIQUERECNO
                  AND SALOFFNO = LASTUSED_REC.UNIQUERECNO2
                  AND NOT EXISTS ( SELECT 1 FROM BI_LOGTOSALOFF
                                  WHERE BI_LOGTOSALOFF.LOGONNO = LOGTOSALOFF.LOGONNO
                                  AND BI_LOGTOSALOFF.SALOFFNO = LOGTOSALOFF.SALOFFNO)
                );
                END;
            END IF;
                  
              -- THIS SHOULD NEVER HAPPEN AS A LOGON IS NEVER DELETED BUT WE'LL STICK IT IN 
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_LOGTOSALOFF WHERE LOGONNO = LASTUSED_REC.UNIQUERECNO
              AND   SALOFFNO  = LASTUSED_REC.UNIQUERECNO2              
              ;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
           
            COMMIT;            
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_LOGTOSALOFF ;

  /* THIS PROCEDURE TAKES SALOFFNO RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_SALOFFNO 
    1Aug16 TV Changed for BI */
  PROCEDURE PROCESS_SALOFFNO AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_SALOFFNO, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_SALOFFNO BI  
              USING 
              ( SELECT SALOFFNO, SALOFFDESC, COMPADD1, COMPADD2, COMPADD3, COMPADD4, POSTCODE, COMPPHONE, COMPFAX, COMPVATNO, sysdate as LASTTOUCHEDDATE FROM SALOFFNO
                  WHERE SALOFFNO = LASTUSED_REC.UNIQUERECNO
                  --AND *-*-* = LASTUSED_REC.UNIQUERECNO2
                  ) 
                  TMPTAB
              ON (TMPTAB.SALOFFNO = BI.SALOFFNO)
              WHEN MATCHED THEN 
                  UPDATE SET  BI.SALOFFDESC = TMPTAB.SALOFFDESC,
				              BI.ADDRESS1   = TMPTAB.COMPADD1, 
				              BI.ADDRESS2   = TMPTAB.COMPADD2, 
				              BI.ADDRESS3   = TMPTAB.COMPADD3, 
				              BI.ADDRESS4   = TMPTAB.COMPADD4, 
				              BI.POSTCODE   = TMPTAB.POSTCODE, 
							        BI.PHONENO    = TMPTAB.COMPPHONE,
							        BI.FAXNO      = TMPTAB.COMPFAX,
							        BI.VATNUMBER  = TMPTAB.COMPVATNO,
                      BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
              WHEN NOT MATCHED THEN
                  INSERT(BI.SALOFFNO, BI.SALOFFDESC, BI.ADDRESS1,  BI.ADDRESS2, BI.ADDRESS3, BI.ADDRESS4, 
				                 BI.POSTCODE, BI.PHONENO, BI.FAXNO, BI.VATNUMBER, BI.LASTTOUCHEDDATE)
                  VALUES(TMPTAB.SALOFFNO,  TMPTAB.SALOFFDESC, TMPTAB.COMPADD1, TMPTAB.COMPADD2, TMPTAB.COMPADD3, TMPTAB.COMPADD4,
   				               TMPTAB.POSTCODE, TMPTAB.COMPPHONE, TMPTAB.COMPFAX, TMPTAB.COMPVATNO, TMPTAB.LASTTOUCHEDDATE );
              END;
            END IF;
                  
              -- THIS SHOULD NEVER HAPPEN AS A PRDALLDESCS IS NEVER DELETED BUT WE'LL STICK IT IN 
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_SALOFFNO WHERE SALOFFNO = LASTUSED_REC.UNIQUERECNO
              --AND   *-*-*  = LASTUSED_REC.UNIQUERECNO2              
              ;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
         
            /* There is no DPTTOSALOFFNO table in Freshtrade, so need to reflag every
               time the sales office changes
            */
            REFLAG_DPTTOSALOFFNO_S(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.OPERATIONTYPE);
            COMMIT;          
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_SALOFFNO ;

  /* THIS PROCEDURE TAKES DEPARTMENTS RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_DEPARTMENTS 
     Amended for BI TV 4Aug16 */
  PROCEDURE PROCESS_DEPARTMENTS AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_DEPARTMENTS,C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_DEPARTMENTS BI  
              USING 
              ( SELECT DPTRECNO, DPT_DESC, sysdate as LASTTOUCHEDDATE FROM DEPARTMENTS
                  WHERE DPTRECNO = LASTUSED_REC.UNIQUERECNO
                  --AND *-*-* = LASTUSED_REC.UNIQUERECNO2
                  ) 
                  TMPTAB
              ON (TMPTAB.DPTRECNO = BI.DPTRECNO)
              WHEN MATCHED THEN 
                  UPDATE SET  BI.DPT_DESC = TMPTAB.DPT_DESC, BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
              WHEN NOT MATCHED THEN
                  INSERT(BI.DPTRECNO, BI.DPT_DESC, BI.LASTTOUCHEDDATE )
                  VALUES(TMPTAB.DPTRECNO,  TMPTAB.DPT_DESC, TMPTAB.LASTTOUCHEDDATE );
              END;
            END IF;
                  
              -- THIS SHOULD NEVER HAPPEN AS A PRDALLDESCS IS NEVER DELETED BUT WE'LL STICK IT IN 
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_DEPARTMENTS WHERE DPTRECNO = LASTUSED_REC.UNIQUERECNO
              --AND   *-*-*  = LASTUSED_REC.UNIQUERECNO2              
              ;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            
            /* There is no DPTTOSALOFFNO table in Freshtrade, so need to reflag every
               time the sales office changes
            */
            REFLAG_DPTTOSALOFFNO_D(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.OPERATIONTYPE);
            COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_DEPARTMENTS ;
  
   /* THIS PROCEDURE TAKES DPTTOSALOFFNO RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_DPTTOSALOFFNO 
      Changed for BI TV 4Aug16*/
  PROCEDURE PROCESS_DPTTOSALOFFNO AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_DPTTOSALOFFNO,C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              INSERT INTO BI_DPTTOSALOFFNO(SALOFFNO, DPTRECNO, LASTTOUCHEDDATE)
              (SELECT LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, sysdate as LASTTOUCHEDDATE FROM DUAL
                WHERE NOT EXISTS ( SELECT 1 FROM BI_DPTTOSALOFFNO
                                  WHERE BI_DPTTOSALOFFNO.SALOFFNO = LASTUSED_REC.UNIQUERECNO
                                  AND BI_DPTTOSALOFFNO.DPTRECNO = LASTUSED_REC.UNIQUERECNO2)
                                  )
                                  ;
              END;
            END IF;
                  
              -- THIS SHOULD NEVER HAPPEN AS A PRDALLDESCS IS NEVER DELETED BUT WE'LL STICK IT IN 
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_DPTTOSALOFFNO WHERE SALOFFNO = LASTUSED_REC.UNIQUERECNO
              AND   DPTRECNO  = LASTUSED_REC.UNIQUERECNO2              
              ;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            COMMIT;            
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_DPTTOSALOFFNO ;
  
   /* THIS PROCEDURE TAKES SMN RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_SMN 
      Changed to BI TV 4Aug16*/
  PROCEDURE PROCESS_SMN AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_SMN,C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_SMN BI  
              USING 
              ( SELECT SMNNO, SMNTYPE,SMNNAME,SMNGRPNAME, sysdate as LASTTOUCHEDDATE FROM SMN
                  WHERE SMNNO = LASTUSED_REC.UNIQUERECNO
                  --AND *-*-* = LASTUSED_REC.UNIQUERECNO2
                  ) 
                  TMPTAB
              ON (TMPTAB.SMNNO = BI.SMNNO)
              WHEN MATCHED THEN 
                  UPDATE SET  BI.SMNTYPE = TMPTAB.SMNTYPE, BI.SMNNAME = TMPTAB.SMNNAME, BI.SMNGRPNAME = TMPTAB.SMNGRPNAME, BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE 
              WHEN NOT MATCHED THEN
                  INSERT(BI.SMNNO, BI.SMNTYPE,BI.SMNNAME, BI.SMNGRPNAME, BI.LASTTOUCHEDDATE )
                  VALUES(TMPTAB.SMNNO,  TMPTAB.SMNTYPE, TMPTAB.SMNNAME, TMPTAB.SMNGRPNAME, TMPTAB.LASTTOUCHEDDATE );
              END;
            END IF;
                  
              -- THIS SHOULD NEVER HAPPEN AS A SMN IS NEVER DELETED BUT WE'LL STICK IT IN 
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_SMN WHERE SMNNO = LASTUSED_REC.UNIQUERECNO;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_SMN ; 
  
  /* THIS PROCEDURE TAKES SMNTOLOGON RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_SMNTOLOGON 
     The handheld software requires that each user is only linked to one saleman,  Therefore, in
     case two or more salesmen are added in FT, the maximum salesman record will always be used
     and this will be the record updated regardless of the salesman actually flagged in the 
     lastused table! TV 22Oct15
	 Altered for BI - not sure that this logic is correct for BI, but will change if it is
	 incorrect TV 4Aug16*/
  PROCEDURE PROCESS_SMNTOLOGON AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_SMNTOLOGON, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_SMNTOLOGON BI  
              USING 
              ( SELECT MAX(SMNNO) AS SMNNO, LOGONNO, sysdate as LASTTOUCHEDDATE FROM SMNTOLOGON
                  WHERE LOGONNO = LASTUSED_REC.UNIQUERECNO2
                  group by logonno
                  ) 
                  TMPTAB
              ON (TMPTAB.SMNNO = BI.SMNNO AND TMPTAB.LOGONNO = BI.LOGONNO)

              WHEN NOT MATCHED THEN
                  INSERT(BI.SMNNO, BI.LOGONNO, BI.LASTTOUCHEDDATE )
                  VALUES(TMPTAB.SMNNO,  TMPTAB.LOGONNO, TMPTAB.LASTTOUCHEDDATE );
              END;
              
              /* Tidy up any old lower valued salesmen */
              DELETE FROM BI_SMNTOLOGON 
                 WHERE LOGONNO = LASTUSED_REC.UNIQUERECNO2 
                 AND SMNNO <>  (SELECT MAX(S2.SMNNO) FROM SMNTOLOGON S2 WHERE S2.LOGONNO = LASTUSED_REC.UNIQUERECNO2);   
              
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_SMNTOLOGON WHERE SMNNO = LASTUSED_REC.UNIQUERECNO and LOGONNO = LASTUSED_REC.UNIQUERECNO2;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_SMNTOLOGON ; 
  
    /* THIS PROCEDURE TAKES DEPARTMENTSTOSMN RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_DEPARTMENTSTOSMN
	   Altered to BI TV 4Aug16*/
  PROCEDURE PROCESS_DEPARTMENTSTOSMN AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_DEPARTMENTSTOSMN, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_DEPARTMENTSTOSMN BI  
              USING 
              ( SELECT SMNNO, DPTRECNO, sysdate as LASTTOUCHEDDATE FROM DEPARTMENTSTOSMN
                  WHERE SMNNO = LASTUSED_REC.UNIQUERECNO2
                  AND DPTRECNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.SMNNO = BI.SMNNO AND TMPTAB.DPTRECNO = BI.DPTRECNO)

              WHEN NOT MATCHED THEN
                  INSERT(BI.SMNNO, BI.DPTRECNO, BI.LASTTOUCHEDDATE )
                  VALUES(TMPTAB.SMNNO,  TMPTAB.DPTRECNO, TMPTAB.LASTTOUCHEDDATE );
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_DEPARTMENTSTOSMN WHERE SMNNO = LASTUSED_REC.UNIQUERECNO2 and DPTRECNO = LASTUSED_REC.UNIQUERECNO;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_DEPARTMENTSTOSMN ;  
  
  /* THIS PROCEDURE TAKES SOFTOSTCLOC RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_SOFTOSTCLOC 
    In order to make sure that there is only one stock location per sales office, the extraction
    checks the DefStcLoc field and ignores the change if the record is not the default
    TV 22Oct15
	Amended for BI ... don't know if this approach is correct but will amend if not TV 4Aug16*/
  PROCEDURE PROCESS_SOFTOSTCLOC AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_SOFTOSTCLOC, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_SOFTOSTCLOC BI  
              USING 
              ( SELECT SOFTOSTCLOC.SALOFFNO, SOFTOSTCLOC.STCLOC, STOCLOC.STCLOCDESC as STCLOCNAME, sysdate as LASTTOUCHEDDATE 
                  FROM SOFTOSTCLOC, STOCLOC
                  WHERE SOFTOSTCLOC.SALOFFNO = LASTUSED_REC.UNIQUERECNO
                  AND SOFTOSTCLOC.STCLOC = LASTUSED_REC.UNIQUERECNO2
                  AND SOFTOSTCLOC.DEFSTCLOC = 1
                  AND SOFTOSTCLOC.STCLOC = STOCLOC.STCRECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.SALOFFNO = BI.SALOFFNO AND TMPTAB.STCLOC = BI.STCLOC)
              WHEN MATCHED THEN 
                  UPDATE SET  BI.STCLOCNAME = TMPTAB.STCLOCNAME, BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE 
              WHEN NOT MATCHED THEN
                  INSERT(BI.SALOFFNO, BI.STCLOC, BI.STCLOCNAME, BI.LASTTOUCHEDDATE )
                  VALUES(TMPTAB.SALOFFNO,  TMPTAB.STCLOC, TMPTAB.STCLOCNAME, TMPTAB.LASTTOUCHEDDATE );
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_SOFTOSTCLOC WHERE SALOFFNO = LASTUSED_REC.UNIQUERECNO and STCLOC = LASTUSED_REC.UNIQUERECNO2;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_SOFTOSTCLOC ; 
  
  
  /* THIS PROCEDURE TAKES ACCCLASS RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO BI_ACCCLASS 
     TV 21Oct15 Added address and postcode 
     TV 19Jan16 Added InterDeptCust 
     TV 1Aug16 Converted for BI*/
  PROCEDURE PROCESS_ACCCLASS AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_ACCCLASS, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_ACCCLASS BI  
              USING 
              ( SELECT CLARECNO, CLAACCCSTSUP, CLAACCCODE, CLAACTIVE, TRIM(CLACONTACTNAME) AS CLACONTACTNAME, TRIM(ACCNAME) AS ACCNAME, CASHCUSTOMER, DEFDLTRECNO,
                  TRIM(ACCADDRESS1) AS ACCADDRESS1, TRIM(ACCADDRESS2) AS ACCADDRESS2, TRIM(ACCADDRESS3) AS ACCADDRESS3, TRIM(ACCADDRESS4) AS ACCADDRESS4, ACCPOSTCODE, TRIM(CLATELENO) AS CLATELENO , TRIM(CLAFAXNO)AS CLAFAXNO,
                  ACCOUNTS.ACCCOUNTRYNO , ACCOUNTS.ACCHOFRECNO, ACCOUNTS.CREDITTERMTYPE, 
                  ACCOUNTS.ACCARCREDITTERMS, ACCOUNTS.ACCARCREDITLIMIT, ACCOUNTS.INTERDEPTCUST, sysdate as LASTTOUCHEDDATE
                  FROM ACCCLASS
                  INNER JOIN ACCOUNTS ON ACCCLASS.CLAACCCODE = ACCOUNTS.ACCCODE
                  WHERE CLARECNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.CLARECNO = BI.CLARECNO)
              WHEN MATCHED THEN 
                  UPDATE SET  BI.CLAACCCSTSUP =TMPTAB.CLAACCCSTSUP, BI.CLAACCCODE = TMPTAB.CLAACCCODE, BI.CLAACTIVE = TMPTAB.CLAACTIVE, 
                  BI.CLACONTACTNAME = TMPTAB.CLACONTACTNAME, BI.ACCNAME = TMPTAB.ACCNAME, BI.CASHCUSTOMER = TMPTAB.CASHCUSTOMER, BI.DEFDLTRECNO = TMPTAB.DEFDLTRECNO,
                  BI.ACCADDRESS1 = TMPTAB.ACCADDRESS1, BI.ACCADDRESS2 = TMPTAB.ACCADDRESS2, BI.ACCADDRESS3 = TMPTAB.ACCADDRESS3, BI.ACCADDRESS4 = TMPTAB.ACCADDRESS4,
                  BI.ACCPOSTCODE = TMPTAB.ACCPOSTCODE, BI.INTERDEPTCUST = TMPTAB.INTERDEPTCUST, BI.ACCCOUNTRYNO = TMPTAB.ACCCOUNTRYNO, BI.CLATELENO = TMPTAB.CLATELENO,
                  BI.CLAFAXNO = TMPTAB.CLAFAXNO, BI.ACCHOFRECNO = TMPTAB.ACCHOFRECNO, BI.CREDITTERMTYPE = TMPTAB.CREDITTERMTYPE, BI.ACCARCREDITTERMS = TMPTAB.ACCARCREDITTERMS,
                  BI.ACCARCREDITLIMIT = TMPTAB.ACCARCREDITLIMIT, BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE 
              WHEN NOT MATCHED THEN
                  INSERT(BI.CLARECNO, BI.CLAACCCSTSUP, BI.CLAACCCODE, BI.CLAACTIVE, BI.CLACONTACTNAME, BI.ACCNAME, BI.CASHCUSTOMER, BI.DEFDLTRECNO, BI.ACCADDRESS1, 
	                       BI.ACCADDRESS2, BI.ACCADDRESS3,	BI.ACCADDRESS4,	BI.ACCPOSTCODE, BI.INTERDEPTCUST, BI.ACCCOUNTRYNO, BI.CLATELENO, BI.CLAFAXNO, BI.ACCHOFRECNO,
                         BI.CREDITTERMTYPE, BI.ACCARCREDITTERMS, BI.ACCARCREDITLIMIT, BI.LASTTOUCHEDDATE)
                  VALUES(TMPTAB.CLARECNO, TMPTAB.CLAACCCSTSUP, TMPTAB.CLAACCCODE, TMPTAB.CLAACTIVE, TMPTAB.CLACONTACTNAME,TMPTAB.ACCNAME, TMPTAB.CASHCUSTOMER, TMPTAB.DEFDLTRECNO,
                         TMPTAB.ACCADDRESS1, TMPTAB.ACCADDRESS2, TMPTAB.ACCADDRESS3, TMPTAB.ACCADDRESS4, TMPTAB.ACCPOSTCODE, TMPTAB.INTERDEPTCUST, TMPTAB.ACCCOUNTRYNO, 
                         TMPTAB.CLATELENO, TMPTAB.CLAFAXNO, TMPTAB.ACCHOFRECNO, TMPTAB.CREDITTERMTYPE, TMPTAB.ACCARCREDITTERMS, TMPTAB.ACCARCREDITLIMIT, TMPTAB.LASTTOUCHEDDATE);
              END;
            END IF;
                  
              -- THIS SHOULD NEVER HAPPEN AS Acclass IS NEVER DELETED BUT WE'LL STICK IT IN 
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_ACCCLASS WHERE CLARECNO = LASTUSED_REC.UNIQUERECNO
              --AND   *-*-*  = LASTUSED_REC.UNIQUERECNO2              
              ;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            COMMIT;          
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_ACCCLASS ;
  
  
/* THIS PROCEDURE TAKES ACCTOSALOFF RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_ACCTOSALOFF 
   Amended for BI TV 4Aug16 */
PROCEDURE PROCESS_ACCTOSALOFF AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_ACCTOSALOFF, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_ACCTOSALOFF BI  
              USING 
              (  select  ACSCLARECNO, ACSSALOFFNO, ACSACCCODE,
                        (Select ContName from DocDistContacts where ContRecNo = (Select Max(D2.ContRecNo) from DocDistContacts D2 where D2.ContClaRecNo = AcsClaRecNo)) as ContName,
                        (Select ContEmailAddress from DocDistContacts where ContRecNo = (Select Max(D3.ContRecNo) from DocDistContacts D3 where D3.ContClaRecNo = AcsClaRecNo)) as ContEmailAddress,
                        (Select ContPhone from DocDistContacts where ContRecNo = (Select Max(D3.ContRecNo) from DocDistContacts D3 where D3.ContClaRecNo = AcsClaRecNo)) as ContPhoneNumber,
                        NVL((Select  NVL2(ContEmailAddress,1,0) from DocDistContacts where ContRecNo = (Select Max(D3.ContRecNo) from DocDistContacts D3 where D3.ContClaRecNo = AcsClaRecNo)),0) as ContSendEmail,
                        ACSARCREDITLIMIT, sysdate as LastTouchedDate
                 from acctosaloff
                 WHERE ACSCLARECNO = LASTUSED_REC.UNIQUERECNO
                 AND ACSSALOFFNO = LASTUSED_REC.UNIQUERECNO2
                 ) 
                  TMPTAB
              ON (TMPTAB.ACSCLARECNO = BI.ACSCLARECNO AND TMPTAB.ACSSALOFFNO = BI.ACSSALOFFNO )
              WHEN MATCHED THEN 
                  UPDATE SET  BI.ACSACCCODE = TMPTAB.ACSACCCODE, 
                  BI.CONTNAME = TMPTAB.CONTNAME, BI.CONTEMAILADDRESS = TMPTAB.CONTEMAILADDRESS, BI.CONTPHONENUMBER = TMPTAB.CONTPHONENUMBER,  
                  BI.CONTSENDEMAIL = TMPTAB.CONTSENDEMAIL, BI.ACSARCREDITLIMIT = TMPTAB.ACSARCREDITLIMIT, BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
              WHEN NOT MATCHED THEN
                  INSERT( BI.ACSCLARECNO,BI.ACSSALOFFNO,  BI.ACSACCCODE,  BI.CONTNAME,  BI.CONTEMAILADDRESS, BI.CONTPHONENUMBER,  BI.CONTSENDEMAIL, BI.ACSARCREDITLIMIT, BI.LASTTOUCHEDDATE )
                  VALUES( TMPTAB.ACSCLARECNO,  TMPTAB.ACSSALOFFNO,  TMPTAB.ACSACCCODE, TMPTAB.CONTNAME, TMPTAB.CONTEMAILADDRESS, TMPTAB.CONTPHONENUMBER, TMPTAB.CONTSENDEMAIL, TMPTAB.ACSARCREDITLIMIT, TMPTAB.LASTTOUCHEDDATE);
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_ACCTOSALOFF WHERE ACSCLARECNO = LASTUSED_REC.UNIQUERECNO
              AND ACSSALOFFNO = LASTUSED_REC.UNIQUERECNO2              
              ;              
            END;
            END IF;
            
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
  
            COMMIT;
        
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    --COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_ACCTOSALOFF ;
   
  
  
  /* THIS PROCEDURE TAKES DLVTYPE RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_DLVTYPE
     1Aug16 TV amended for BI*/
  PROCEDURE PROCESS_DLVTYPE AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_DLVTYPE, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_DLVTYPE BI  
              USING 
              ( SELECT DLTRECNO, DELIVERYCONDITION,  DELIVERYCONDITIONDESC, sysdate as LASTTOUCHEDDATE FROM DLVTYPE
                  WHERE DLTRECNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.DLTRECNO = BI.DLTRECNO )
              WHEN MATCHED THEN 
                  UPDATE SET BI.DELIVERYCONDITION = TMPTAB.DELIVERYCONDITION,  BI.DELIVERYCONDITIONDESC = TMPTAB.DELIVERYCONDITIONDESC, BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
              WHEN NOT MATCHED THEN
                  INSERT(BI.DLTRECNO, BI.DELIVERYCONDITION,  BI.DELIVERYCONDITIONDESC, BI.LASTTOUCHEDDATE)
                  VALUES(TMPTAB.DLTRECNO, TMPTAB.DELIVERYCONDITION,  TMPTAB.DELIVERYCONDITIONDESC, TMPTAB.LASTTOUCHEDDATE);
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_DLVTYPE WHERE DLTRECNO = LASTUSED_REC.UNIQUERECNO            
              ;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            COMMIT;          
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_DLVTYPE ;
  
  /* THIS PROCEDURE TAKES ACCCURRDESC RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO BI_ACCCURRDESC
     9Aug16 TV Written for BI*/
  PROCEDURE PROCESS_ACCCURRDESC AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_ACCCURRDESC, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_ACCCURRDESC BI  
              USING 
              ( SELECT CURNO,CURDESC,CURTRIANGREQ,CURDECIMALPLACES,CURDECIMALPOINT,CURTHOUSANDSEPARATOR,
                       TRIM(CURSYMBOL) as CURSYMBOL,CURSYMBOLATFRONT,CURUNITNUMPICTURE,CUREXTNNUMPICTURE,CURDEFBANRECNO,
                       CURCODE, sysdate as LASTTOUCHEDDATE FROM ACCCURRDESC
                  WHERE CURNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.CURNO = BI.CURNO )
              WHEN MATCHED THEN 
                  UPDATE SET 
				     BI.CURDESC = TMPTAB.CURDESC,
				     BI.CURTRIANGREQ = TMPTAB.CURTRIANGREQ,
				     BI.CURDECIMALPLACES = TMPTAB.CURDECIMALPLACES,
				     BI.CURDECIMALPOINT = TMPTAB.CURDECIMALPOINT,
				     BI.CURTHOUSANDSEPARATOR = TMPTAB.CURTHOUSANDSEPARATOR,
				     BI.CURSYMBOL = TMPTAB.CURSYMBOL,
				     BI.CURSYMBOLATFRONT = TMPTAB.CURSYMBOLATFRONT,
				     BI.CURUNITNUMPICTURE = TMPTAB.CURUNITNUMPICTURE,
				     BI.CUREXTNNUMPICTURE = TMPTAB.CUREXTNNUMPICTURE,
				     BI.CURDEFBANRECNO = TMPTAB.CURDEFBANRECNO,
				     BI.CURCODE = TMPTAB.CURCODE,
					 BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
              WHEN NOT MATCHED THEN
                  INSERT(BI.CURNO, BI.CURDESC, BI.CURTRIANGREQ, BI.CURDECIMALPLACES, BI.CURDECIMALPOINT, BI.CURTHOUSANDSEPARATOR, 
				         BI.CURSYMBOL, BI.CURSYMBOLATFRONT, BI.CURUNITNUMPICTURE, BI.CUREXTNNUMPICTURE, BI.CURDEFBANRECNO, 
						 BI.CURCODE, BI.LASTTOUCHEDDATE)
                  VALUES(TMPTAB.CURNO, TMPTAB.CURDESC, TMPTAB.CURTRIANGREQ, TMPTAB.CURDECIMALPLACES, TMPTAB.CURDECIMALPOINT, TMPTAB.CURTHOUSANDSEPARATOR, 
				         TMPTAB.CURSYMBOL, TMPTAB.CURSYMBOLATFRONT, TMPTAB.CURUNITNUMPICTURE, TMPTAB.CUREXTNNUMPICTURE, TMPTAB.CURDEFBANRECNO, 
						 TMPTAB.CURCODE, TMPTAB.LASTTOUCHEDDATE);
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_ACCCURRDESC WHERE CURNO = LASTUSED_REC.UNIQUERECNO            
              ;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            
			COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_ACCCURRDESC ;
    
	
/* THIS PROCEDURE TAKES CHGTYP RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO BI_CHGTYP
     9Aug16 TV Written for BI*/
  PROCEDURE PROCESS_CHGTYP AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_CHGTYP, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_CHGTYP BI  
              USING 
              ( SELECT CTYNO,CTYDESC,CTYAPPBY,CTYCHGTONO,INBOUNDHAUL,CALCONRCVQTY,CHARGECLASS,ZZ_EXTRACTTOFLATFILE,
                       AUTHEXP,ANSI810EDI,ANSI880EDI,ZZ_EXTTOFLATFILE_SALESCHGS,CHGCALCONALLOCATED,CHGAMENDREQUIRESPERMISSION,
                       CHGIGNORECRDR,SYSTEMCHG, sysdate as LASTTOUCHEDDATE FROM CHGTYP
                  WHERE CTYNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.CTYNO = BI.CTYNO )
              WHEN MATCHED THEN 
                  UPDATE SET 
				     BI.CTYDESC = TMPTAB.CTYDESC,
				     BI.CTYAPPBY = TMPTAB.CTYAPPBY,
				     BI.CTYCHGTONO = TMPTAB.CTYCHGTONO,
				     BI.INBOUNDHAUL = TMPTAB.INBOUNDHAUL,
				     BI.CALCONRCVQTY = TMPTAB.CALCONRCVQTY,
				     BI.CHARGECLASS = TMPTAB.CHARGECLASS,
				     BI.ZZ_EXTRACTTOFLATFILE = TMPTAB.ZZ_EXTRACTTOFLATFILE,
				     BI.AUTHEXP = TMPTAB.AUTHEXP,
				     BI.ANSI810EDI = TMPTAB.ANSI810EDI,
				     BI.ANSI880EDI = TMPTAB.ANSI880EDI,
				     BI.ZZ_EXTTOFLATFILE_SALESCHGS = TMPTAB.ZZ_EXTTOFLATFILE_SALESCHGS,
				     BI.CHGCALCONALLOCATED = TMPTAB.CHGCALCONALLOCATED,
				     BI.CHGAMENDREQUIRESPERMISSION = TMPTAB.CHGAMENDREQUIRESPERMISSION,
				     BI.CHGIGNORECRDR = TMPTAB.CHGIGNORECRDR,
				     BI.SYSTEMCHG = TMPTAB.SYSTEMCHG,
		        	 BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
              WHEN NOT MATCHED THEN
                  INSERT(BI.CTYNO, BI.CTYDESC, BI.CTYAPPBY, BI.CTYCHGTONO, BI.INBOUNDHAUL, BI.CALCONRCVQTY, BI.CHARGECLASS, BI.ZZ_EXTRACTTOFLATFILE, 
				         BI.AUTHEXP, BI.ANSI810EDI, BI.ANSI880EDI, BI.ZZ_EXTTOFLATFILE_SALESCHGS, BI.CHGCALCONALLOCATED, BI.CHGAMENDREQUIRESPERMISSION, 
						 BI.CHGIGNORECRDR, BI.SYSTEMCHG, BI.LASTTOUCHEDDATE)
                  VALUES(TMPTAB.CTYNO, TMPTAB.CTYDESC, TMPTAB.CTYAPPBY, TMPTAB.CTYCHGTONO, TMPTAB.INBOUNDHAUL, TMPTAB.CALCONRCVQTY, TMPTAB.CHARGECLASS, 
				         TMPTAB.ZZ_EXTRACTTOFLATFILE, TMPTAB.AUTHEXP, TMPTAB.ANSI810EDI, TMPTAB.ANSI880EDI, TMPTAB.ZZ_EXTTOFLATFILE_SALESCHGS, 
						 TMPTAB.CHGCALCONALLOCATED, TMPTAB.CHGAMENDREQUIRESPERMISSION, TMPTAB.CHGIGNORECRDR, TMPTAB.SYSTEMCHG, TMPTAB.LASTTOUCHEDDATE);
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_CHGTYP WHERE CTYNO = LASTUSED_REC.UNIQUERECNO;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            
			COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_CHGTYP ;
    

/* THIS PROCEDURE TAKES COUNTRY RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO BI_COUNTRY
     9Aug16 TV Written for BI*/
  PROCEDURE PROCESS_COUNTRY AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_COUNTRY, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_COUNTRY BI  
              USING 
              ( SELECT COUCOURECNO,COUCOUDESC,COUCOUEECM,INTRASTATCODE,
                       sysdate as LASTTOUCHEDDATE FROM COUNTRY
                  WHERE COUCOURECNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.COUCOURECNO = BI.COUCOURECNO )
              WHEN MATCHED THEN 
                  UPDATE SET 
				     BI.COUCOUDESC = TMPTAB.COUCOUDESC,
				     BI.COUCOUEECM = TMPTAB.COUCOUEECM,
				     BI.INTRASTATCODE = TMPTAB.INTRASTATCODE,
				     BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
              WHEN NOT MATCHED THEN
                  INSERT(BI.COUCOURECNO, BI.COUCOUDESC, BI.COUCOUEECM, BI.INTRASTATCODE,
                         BI.LASTTOUCHEDDATE)
                  VALUES(TMPTAB.COUCOURECNO, TMPTAB.COUCOUDESC, TMPTAB.COUCOUEECM, TMPTAB.INTRASTATCODE,
                         TMPTAB.LASTTOUCHEDDATE);
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_COUNTRY WHERE COUCOURECNO = LASTUSED_REC.UNIQUERECNO;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            
			COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_COUNTRY ;
    
			
/* THIS PROCEDURE TAKES CSTANGRP RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO BI_CSTANGRP
     9Aug16 TV Written for BI*/
  PROCEDURE PROCESS_CSTANGRP AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_CSTANGRP, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_CSTANGRP BI  
              USING 
              ( SELECT CSGRECNO,CSGDESC,CSGNOOFCST,CSGTYPE,CSGCONTAINERGROUP,
                       sysdate as LASTTOUCHEDDATE FROM CSTANGRP
                  WHERE CSGRECNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.CSGRECNO = BI.CSGRECNO )
              WHEN MATCHED THEN 
                  UPDATE SET 
				     BI.CSGDESC = TMPTAB.CSGDESC,
				     BI.CSGNOOFCST = TMPTAB.CSGNOOFCST,
					 BI.CSGTYPE = TMPTAB.CSGTYPE,
					 BI.CSGCONTAINERGROUP = TMPTAB.CSGCONTAINERGROUP,
					 BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
              WHEN NOT MATCHED THEN
                  INSERT(BI.CSGRECNO, BI.CSGDESC, BI.CSGNOOFCST, BI.CSGTYPE, BI.CSGCONTAINERGROUP,
                         BI.LASTTOUCHEDDATE)
                  VALUES(TMPTAB.CSGRECNO, TMPTAB.CSGDESC, TMPTAB.CSGNOOFCST, TMPTAB.CSGTYPE, TMPTAB.CSGCONTAINERGROUP,
                         TMPTAB.LASTTOUCHEDDATE);
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_CSTANGRP WHERE CSGRECNO = LASTUSED_REC.UNIQUERECNO;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            
			COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_CSTANGRP ;
    
			
/* THIS PROCEDURE TAKES CSTANDES RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO BI_CSTANDES
     9Aug16 TV Written for BI*/
  PROCEDURE PROCESS_CSTANDES AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_CSTANDES, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_CSTANDES BI  
              USING 
              ( SELECT CSARECNO,CSACSGRECNO,TRIM(CSADESC) as CSADESC,
                       sysdate as LASTTOUCHEDDATE FROM CSTANDES
                  WHERE CSARECNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.CSARECNO = BI.CSARECNO )
              WHEN MATCHED THEN 
                  UPDATE SET 
				     BI.CSACSGRECNO = TMPTAB.CSACSGRECNO,
				     BI.CSADESC = TMPTAB.CSADESC,
				     BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
              WHEN NOT MATCHED THEN
                  INSERT(BI.CSARECNO, BI.CSACSGRECNO, BI.CSADESC,
                         BI.LASTTOUCHEDDATE)
                  VALUES(TMPTAB.CSARECNO, TMPTAB.CSACSGRECNO, TMPTAB.CSADESC,
                         TMPTAB.LASTTOUCHEDDATE);
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_CSTANDES WHERE CSARECNO = LASTUSED_REC.UNIQUERECNO;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            
			      COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_CSTANDES ;
    
	
	
  /* THIS PROCEDURE TAKES CSTANREC RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO BI_CSTANREC
     9Aug16 TV Written for BI*/
  PROCEDURE PROCESS_CSTANREC AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_CSTANREC, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_CSTANREC BI  
              USING 
              ( SELECT CSDCSGRECNO,CSDCSTCODE,CSDCSARECNO,
                       sysdate as LASTTOUCHEDDATE FROM CSTANREC
                  WHERE CSDCSGRECNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON ((TMPTAB.CSDCSGRECNO = BI.CSDCSGRECNO) AND (TMPTAB.CSDCSTCODE = BI.CSDCSTCODE) AND (TMPTAB.CSDCSARECNO = BI.CSDCSARECNO))
              WHEN MATCHED THEN 
                  UPDATE SET 
				     BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
              WHEN NOT MATCHED THEN
                  INSERT(BI.CSDCSGRECNO, BI.CSDCSTCODE, BI.CSDCSARECNO,
                         BI.LASTTOUCHEDDATE)
                  VALUES(TMPTAB.CSDCSGRECNO, TMPTAB.CSDCSTCODE, TMPTAB.CSDCSARECNO,
                         TMPTAB.LASTTOUCHEDDATE);
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_CSTANREC WHERE CSDCSGRECNO = LASTUSED_REC.UNIQUERECNO;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            
			COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_CSTANREC ;
			
		
  /* THIS PROCEDURE TAKES FIXEDROUTES RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO BI_FIXEDROUTES
     9Aug16 TV Written for BI*/
  PROCEDURE PROCESS_FIXEDROUTES AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_FIXEDROUTES, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_FIXEDROUTES BI  
              USING 
              ( SELECT FRRECNO,FRDESCRIPTION,SALOFFNO,
                       sysdate as LASTTOUCHEDDATE FROM FIXEDROUTES
                  WHERE FRRECNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.FRRECNO = BI.FRRECNO)
              WHEN MATCHED THEN 
                  UPDATE SET 
				     BI.FRDESCRIPTION = TMPTAB.FRDESCRIPTION,
					 BI.SALOFFNO = TMPTAB.SALOFFNO,
				     BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
              WHEN NOT MATCHED THEN
                  INSERT(BI.FRRECNO, BI.FRDESCRIPTION, BI.SALOFFNO,
                         BI.LASTTOUCHEDDATE)
                  VALUES(TMPTAB.FRRECNO, TMPTAB.FRDESCRIPTION, TMPTAB.SALOFFNO,
                         TMPTAB.LASTTOUCHEDDATE);
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_FIXEDROUTES WHERE FRRECNO = LASTUSED_REC.UNIQUERECNO;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            
			COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_FIXEDROUTES ;

  
 /* THIS PROCEDURE TAKES HOFCST RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO BI_HOFCST
     9Aug16 TV Written for BI*/

  PROCEDURE PROCESS_HOFCST AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_HOFCST, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_HOFCST BI  
              USING 
              ( SELECT HOFRECNO,CURRENCYCODE,SALOFFNO,HOFINVTOCSTCODE,USEUPLOADHOF,
                       LSTINVOUT,SUPPLIERREF,INVSALOFFNO,SUPPREF,ACCRECNO,
                       SUPPLIERINVREF, sysdate as LASTTOUCHEDDATE FROM HOFCST
                  WHERE HOFRECNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.HOFRECNO = BI.HOFRECNO)
              WHEN MATCHED THEN 
                  UPDATE SET 
				     BI.CURRENCYCODE = TMPTAB.CURRENCYCODE,
					 BI.SALOFFNO = TMPTAB.SALOFFNO,
					 BI.HOFINVTOCSTCODE = TMPTAB.HOFINVTOCSTCODE,
					 BI.USEUPLOADHOF = TMPTAB.USEUPLOADHOF,
					 BI.LSTINVOUT = TMPTAB.LSTINVOUT,
					 BI.SUPPLIERREF = TMPTAB.SUPPLIERREF,
					 BI.INVSALOFFNO = TMPTAB.INVSALOFFNO,
					 BI.SUPPREF = TMPTAB.SUPPREF,
					 BI.ACCRECNO = TMPTAB.ACCRECNO,
					 BI.SUPPLIERINVREF = TMPTAB.SUPPLIERINVREF,
					 BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
              WHEN NOT MATCHED THEN
                  INSERT(BI.HOFRECNO, BI.CURRENCYCODE, BI.SALOFFNO, BI.HOFINVTOCSTCODE, BI.USEUPLOADHOF, 
                       BI.LSTINVOUT, BI.SUPPLIERREF, BI.INVSALOFFNO, BI.SUPPREF, BI.ACCRECNO, 
					   BI.SUPPLIERINVREF, BI.LASTTOUCHEDDATE)
                  VALUES(TMPTAB.HOFRECNO, TMPTAB.CURRENCYCODE, TMPTAB.SALOFFNO, TMPTAB.HOFINVTOCSTCODE, TMPTAB.USEUPLOADHOF, 
                       TMPTAB.LSTINVOUT, TMPTAB.SUPPLIERREF, TMPTAB.INVSALOFFNO, TMPTAB.SUPPREF, TMPTAB.ACCRECNO, 
					   TMPTAB.SUPPLIERINVREF, TMPTAB.LASTTOUCHEDDATE);
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_HOFCST WHERE HOFRECNO = LASTUSED_REC.UNIQUERECNO;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            
			COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_HOFCST ;

		
		 
 /* THIS PROCEDURE TAKES PRDGROUPCAT RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO BI_PRDGROUPCAT
     9Aug16 TV Written for BI*/

  PROCEDURE PROCESS_PRDGROUPCAT AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_PRDGROUPCAT, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_PRDGROUPCAT BI  
              USING 
              ( SELECT PRDCATNO,PRDCATDESC,
                       sysdate as LASTTOUCHEDDATE FROM PRDGROUPCAT
                  WHERE PRDCATNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.PRDCATNO = BI.PRDCATNO)
              WHEN MATCHED THEN 
                  UPDATE SET 
				     BI.PRDCATDESC = TMPTAB.PRDCATDESC,
					 BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
              WHEN NOT MATCHED THEN
                  INSERT(BI.PRDCATNO, BI.PRDCATDESC, BI.LASTTOUCHEDDATE)
                  VALUES(TMPTAB.PRDCATNO, TMPTAB.PRDCATDESC, TMPTAB.LASTTOUCHEDDATE);
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_PRDGROUPCAT WHERE PRDCATNO = LASTUSED_REC.UNIQUERECNO;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            
			COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_PRDGROUPCAT ;

 /* THIS PROCEDURE TAKES PRDGROUPCATREC RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO BI_PRDGROUPCATREC
     10Aug16 TV Written for BI*/

  PROCEDURE PROCESS_PRDGROUPCATREC AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_PRDGROUPCATREC, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_PRDGROUPCATREC BI  
              USING 
              ( SELECT PRDCATNO,ALLPREF1,ALLPREF2,ALLPREF3,ALLPREF4,ALLPREF5,ALLPREF6,
                       sysdate as LASTTOUCHEDDATE FROM PRDGROUPCATREC
                  WHERE PRDCATNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.PRDCATNO = BI.PRDCATNO and TMPTAB.ALLPREF1 = BI.ALLPREF1  
			      and TMPTAB.ALLPREF2 = BI.ALLPREF2 and TMPTAB.ALLPREF3 = BI.ALLPREF3
				  and TMPTAB.ALLPREF4 = BI.ALLPREF4 and TMPTAB.ALLPREF5 = BI.ALLPREF5
				  and TMPTAB.ALLPREF6 = BI.ALLPREF6)
              WHEN MATCHED THEN 
                  UPDATE SET 
				     BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
              WHEN NOT MATCHED THEN
                  INSERT(BI.PRDCATNO, BI.ALLPREF1, BI.ALLPREF2, BI.ALLPREF3, 
				         BI.ALLPREF4, BI.ALLPREF5, BI.ALLPREF6, BI.LASTTOUCHEDDATE )
                  VALUES(TMPTAB.PRDCATNO, TMPTAB.ALLPREF1, TMPTAB.ALLPREF2, TMPTAB.ALLPREF3, 
				         TMPTAB.ALLPREF4, TMPTAB.ALLPREF5, TMPTAB.ALLPREF6, TMPTAB.LASTTOUCHEDDATE );
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_PRDGROUPCATREC WHERE PRDCATNO = LASTUSED_REC.UNIQUERECNO;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            
			COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_PRDGROUPCATREC ;
  
  	 
 /* THIS PROCEDURE TAKES PRDGROUPGRP RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO BI_PRDGROUPGRP
     10Aug16 TV Written for BI*/

  PROCEDURE PROCESS_PRDGROUPGRP AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_PRDGROUPGRP, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_PRDGROUPGRP BI  
              USING 
              ( SELECT PRDGRPNO,PRDGRPDESC,SALOFFNO,STCRECNO,
                       sysdate as LASTTOUCHEDDATE FROM PRDGROUPGRP
                  WHERE PRDGRPNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.PRDGRPNO = BI.PRDGRPNO)
              WHEN MATCHED THEN 
                  UPDATE SET 
				     BI.PRDGRPDESC = TMPTAB.PRDGRPDESC,
				     BI.SALOFFNO = TMPTAB.SALOFFNO,
				     BI.STCRECNO = TMPTAB.STCRECNO,
				     BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
              WHEN NOT MATCHED THEN
                  INSERT(BI.PRDGRPNO, BI.PRDGRPDESC, BI.SALOFFNO, BI.STCRECNO, BI.LASTTOUCHEDDATE )
                  VALUES(TMPTAB.PRDGRPNO, TMPTAB.PRDGRPDESC, TMPTAB.SALOFFNO, TMPTAB.STCRECNO, TMPTAB.LASTTOUCHEDDATE );
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_PRDGROUPGRP WHERE PRDGRPNO = LASTUSED_REC.UNIQUERECNO;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            
			COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_PRDGROUPGRP ;

  
 /* THIS PROCEDURE TAKES PRDGROUPGRPREC RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO BI_PRDGROUPGRPREC
     10Aug16 TV Written for BI*/

  PROCEDURE PROCESS_PRDGROUPGRPREC AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_PRDGROUPGRPREC, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;

      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_PRDGROUPGRPREC BI  
              USING 
              ( SELECT PRDGRPNO,PRDCATNO,
                       sysdate as LASTTOUCHEDDATE FROM PRDGROUPGRPREC
                  WHERE PRDGRPNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON ((TMPTAB.PRDGRPNO = BI.PRDGRPNO) AND (TMPTAB.PRDCATNO = BI.PRDCATNO))
              WHEN MATCHED THEN 
                  UPDATE SET 
				     BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
              WHEN NOT MATCHED THEN
                  INSERT(BI.PRDGRPNO, BI.PRDCATNO, BI.LASTTOUCHEDDATE )
                  VALUES(TMPTAB.PRDGRPNO, TMPTAB.PRDCATNO, TMPTAB.LASTTOUCHEDDATE );
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_PRDGROUPGRPREC WHERE PRDGRPNO = LASTUSED_REC.UNIQUERECNO;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            
			COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_PRDGROUPGRPREC ;


/* THIS PROCEDURE TAKES DOCDISTCONTACTS RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO BI_DOCDISTCONTACTS
     11Aug16 TV Written for BI*/
  PROCEDURE PROCESS_DOCDISTCONTACTS AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_DOCDISTCONTACTS, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;

      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_DOCDISTCONTACTS BI  
              USING 
              ( SELECT CONTRECNO,CONTCLARECNO,CONTNAME,CONTEMAILADDRESS,CONTFAXNO,CONTDEPT,CONTPHONE,
                       sysdate as LASTTOUCHEDDATE FROM DOCDISTCONTACTS
                  WHERE CONTRECNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.CONTRECNO = BI.CONTRECNO)
              WHEN MATCHED THEN 
                  UPDATE SET 
				     BI.CONTCLARECNO = TMPTAB.CONTCLARECNO,
				     BI.CONTNAME = TMPTAB.CONTNAME,
				     BI.CONTEMAILADDRESS = TMPTAB.CONTEMAILADDRESS,
				     BI.CONTFAXNO = TMPTAB.CONTFAXNO,
				     BI.CONTDEPT = TMPTAB.CONTDEPT,
				     BI.CONTPHONE = TMPTAB.CONTPHONE,
				     BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
              WHEN NOT MATCHED THEN
                  INSERT(BI.CONTRECNO, BI.CONTCLARECNO, BI.CONTNAME, BI.CONTEMAILADDRESS, BI.CONTFAXNO, BI.CONTDEPT, BI.CONTPHONE, BI.LASTTOUCHEDDATE )
                  VALUES(TMPTAB.CONTRECNO, TMPTAB.CONTCLARECNO, TMPTAB.CONTNAME, TMPTAB.CONTEMAILADDRESS, TMPTAB.CONTFAXNO, TMPTAB.CONTDEPT, TMPTAB.CONTPHONE,
    				     TMPTAB.LASTTOUCHEDDATE );
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM BI_DOCDISTCONTACTS WHERE CONTRECNO = LASTUSED_REC.UNIQUERECNO;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            
			COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_DOCDISTCONTACTS ;

/* THIS PROCEDURE TAKES DGPHEAD RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO BI_DGPHEADER
     11Aug16 TV Written for BI*/
  PROCEDURE PROCESS_DGPHEADER AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_DGPHEADER, C_BI);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;

      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO BI_DGPHEADER BI
              USING 
              ( SELECT DGPHEDRECNO,DGPSALOFFNO,DGPEXTRACTDATE,DGPEXTRACTED,DGPCLOSED,
                       sysdate as LASTTOUCHEDDATE FROM DGPHEAD
                  WHERE DGPHEDRECNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.DGPHEDRECNO = BI.DGPHEDRECNO)
              WHEN MATCHED THEN 
                  UPDATE SET 
				     BI.DGPSALOFFNO = TMPTAB.DGPSALOFFNO,
				     BI.DGPEXTRACTDATE = TMPTAB.DGPEXTRACTDATE,
				     BI.DGPEXTRACTED = TMPTAB.DGPEXTRACTED,
				     BI.DGPCLOSED = TMPTAB.DGPCLOSED,
				     BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
              WHEN NOT MATCHED THEN
                  INSERT(BI.DGPHEDRECNO, BI.DGPSALOFFNO, BI.DGPEXTRACTDATE, BI.DGPEXTRACTED, BI.DGPCLOSED, BI.LASTTOUCHEDDATE )
                  VALUES(TMPTAB.DGPHEDRECNO, TMPTAB.DGPSALOFFNO, TMPTAB.DGPEXTRACTDATE, TMPTAB.DGPEXTRACTED, TMPTAB.DGPCLOSED, TMPTAB.LASTTOUCHEDDATE );
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              --DELETE FROM BI_DGPHEADER WHERE BI_DGPHEADER.DGPHEADRECNO = LASTUSED_REC.UNIQUERECNO;   
              DELETE FROM BI_DGPHEADER WHERE DGPHEDRECNO = LASTUSED_REC.UNIQUERECNO;              
    
            END;
            END IF; 
            
            PROCESS_DGPDETAILS(LASTUSED_REC.UNIQUERECNO,LASTUSED_REC.OPERATIONTYPE);  

            PROCESS_DGPCHARGETAB(LASTUSED_REC.UNIQUERECNO,LASTUSED_REC.OPERATIONTYPE); 
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_BI);
            
			COMMIT;
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_DGPHEADER ;
  
  /* THIS PROCEDURE TAKES DGPDETAILS RECORDS WRITES THEM TO BI_DGPDETAILS. CALLED BY PROCESS_DGPHEADER 
     Amended TV 10Oct16 */
   PROCEDURE	PROCESS_DGPDETAILS (IN_DGPHEDRECNO NUMBER, IN_OPERATIONTYPE VARCHAR2)
   AS   
   BEGIN
     
     IF IN_OPERATIONTYPE = C_CREATE 
     OR IN_OPERATIONTYPE = C_UPDATE THEN    
     BEGIN   
       MERGE INTO BI_DGPDETAILS BI  
       USING 
            ( 
				Select DGPhead.DGPEXTRACTDATE DGP_Extraction_Date
				, DGPDetails.DGPDETRECNO Transaction_Number
				, DGPDetails.DGPDLVDATE Delivery_Date
				, DGPhead.DGPSALOFFNO Sales_Office_Number
				, DGPDetails.DGPDLVNO Delivery_Number
				, TNTNO as Ticket_Number
				, AtrRef as Invoice_Number
				, DGPDetails.DGPCLARECNO Customer_Number
				, Lotite.LitSenCode Supplier_Number
				, DGPPRDNO Product_Number
				, (Select DPTRECNO From DEPARTMENTSTOSMN Where Lotite.LitBuyer = DEPARTMENTSTOSMN.SMNNO) DEPARTMENT
				, PorNo PO_Number
				, Lothed.LHERECNO Lot_Number
				, Lotite.LititeNo Lot_Line_Number
				, NVL(LITPAYTYP, LHEPAYTYP) Lot_Purchase_Type
				, Orders.ORDSMNNO Salesman_Number
				, Case when Abs(NVL(DGPCLOSFINDECQTY,0) - NVL(DGPOPENFINDECQTY,0)) > 0.009
					   then NVL(DGPCLOSFINDECQTY,0) - NVL(DGPOPENFINDECQTY,0)
					   else NVL(DGPCLOSEFINQTY,0) - NVL(DGPOPENFINQTY,0)
					   end Packs_Move
				,NVL(DGPCLOSEDELAMM,0) - NVL(DGPOPENDELAMM,0) Gross_SaleValue_Move
				,NVL(DGPCLOSEONDISC,0) - NVL(DGPOPENONDISC,0) Rebate_Move
				,NVL(DGPCLOSEOFFDISC,0) - NVL(DGPOPENOFFDISC,0) Discount_Move
				,NVL(DGPCLOSEOTHERS,0) - NVL(DGPOPENOTHERS,0) Other_SalesCost_Move
				,Case When Abs(NVL(DGPCLOSDECPRDCOST,0) - NVL(DGPOPENDECPRDCOST,0)) > 0.009
					  then NVL(DGPCLOSDECPRDCOST,0) - NVL(DGPOPENDECPRDCOST,0)
					  else NVL(DGPCLOSDLVPRDCOST,0) - NVL(DGPOPENDLVPRDCOST,0)
					  end Delivered_Goods_Cost
				,CASE When (Abs(NVL(DGPOPENFINDECQTY,0)) < 0.009
						   and Abs(NVL(DGPOPENFINQTY,0)) <0.009
						   and Abs(NVL(DGPOPENDELAMM,0)) <0.009
						   and Abs(NVL(DGPOPENONDISC,0)) <0.009
						   and Abs(NVL(DGPOPENOFFDISC,0)) <0.009
						   and Abs(NVL(DGPOPENOTHERS,0)) <0.009
						   and Abs(NVL(DGPOPENDECPRDCOST,0)) <0.009
						   and Abs(NVL(DGPOPENDLVPRDCOST,0)) <0.009
               AND (Abs(NVL(DGPCLOSFINDECQTY,0)) > 0.009
						        OR Abs(NVL(DGPCLOSEFINQTY,0)) > 0.009
						        OR Abs(NVL(DGPCLOSEDELAMM,0)) >0.009
						        OR Abs(NVL(DGPCLOSEONDISC,0)) >0.009
						        OR Abs(NVL(DGPCLOSEOFFDISC,0)) >0.009
						        OR Abs(NVL(DGPCLOSEOTHERS,0)) >0.009
						        OR Abs(NVL(DGPCLOSDECPRDCOST,0)) >0.009
						        OR Abs(NVL(DGPCLOSDLVPRDCOST,0)) >0.009
                   ) 
               )
						   then 1
						   else 0
						   end New_Transaction_Flag,
				Deldet.DELQTYPER,
				NVL(DGPCLOSEFINQTY,0) - NVL(DGPOPENFINQTY,0) Sales_Packs_Move,
				Deldet.DELRECNO,
        PurOrd.RcvDate as RECEIVEDDATE,
        DelHed.TrnSalOffNo,
        DelHed.InterDeptFlag,
        DelHed.DlvDltRecNo as DLVTYPE,
        DelHed.DlvSalTyp as DLVSALTYPE,
        Case when Abs(NVL(DGPCLOSFINDECQTY,0) - NVL(DGPOPENFINDECQTY,0)) > 0.009
					   then NVL(DGPCLOSFINDECQTY,0) - NVL(DGPOPENFINDECQTY,0) * (select Nvl(PrcWeight,0) from prdrec where prcprdno = Deldet.DelPrcPrdNo)
					   else NVL(DGPCLOSEFINQTY,0) - NVL(DGPOPENFINQTY,0) * (select Nvl(PrcWeight,0) from prdrec where prcprdno = Deldet.DelPrcPrdNo)
					   end SALES_PACKS_WEIGHT,
        DelHed.DlvRthNo as Route_Number,    
        DelHed.DropRteNo, 
        DelDet.DelPricePer,
        DGPDetails.DGPIstPrdNo,
        DGPDEtails.DGPWODocNo as WO_NUMBER,
        DelHed.DlvSalTyp as SALESTYPE,
        (Select DPTRECNO From DEPARTMENTSTOSMN Where Lotite.LitBuyer = DEPARTMENTSTOSMN.SMNNO) STOCK_DEPT_NUMBER,
        DGPHEDRECNO,
        sysdate as LASTTOUCHEDDATE
				from DGPDetails, DGPhead, Lotite, PurOrd, LotDet, Lothed, Delhed, Orders, TKTNT, Delprice, Acctrnfil, Deldet
				Where DGPDetails.DGPDETHEDNO = DGPHead.DGPHEDRECNO
				And DGPDetails.DgpLitRecNo = Lotite.LititeNo
				And Lotite.LitPorrec = Purord.PorRecNo
				And Lotite.LITDETNO = LotDet.DETRECNO
				And LotDet.DETLHERECNO = Lothed.LHERECNO
				And DgpDetails.DGPDLVNO = Delhed.DlvOrdNo
				And Delhed.DlvOrdRecNo = Orders.OrdRecNo
				And DgpDprRecNO = DprrecNo
				And Delprice.DprDelRecNo = Deldet.DelRecNo
				And DelInvRecNo = AccTrnFil.AtrRecNo(+)
				And DGPDetails.DGPDLVNO = TKTNT.TNTDLVORDNO(+)
				And NVL(DGPhead.DGPCLOSED,0) = 1
				AND DGPHEDRECNO = IN_DGPHEDRECNO
				    ) 
               TMPTAB
            ON (BI.DGPDETAILRECNO = TMPTAB.TRANSACTION_NUMBER)
            WHEN MATCHED THEN 
                UPDATE SET 
					BI.DGPHEDRECNO = TMPTAB.DGPHEDRECNO, 
					BI.DGP_EXTRACTION_DATE = TMPTAB.DGP_EXTRACTION_DATE, 
					BI.TRANSACTION_NUMBER = TMPTAB.TRANSACTION_NUMBER, 
					BI.DELIVERY_DATE = TMPTAB.DELIVERY_DATE, 
					BI.SALES_OFFICE_NUMBER = TMPTAB.SALES_OFFICE_NUMBER, 
					BI.DELIVERY_NUMBER = TMPTAB.DELIVERY_NUMBER, 
					BI.TICKET_NUMBER = TMPTAB.TICKET_NUMBER, 
					BI.INVOICE_NUMBER = TMPTAB.INVOICE_NUMBER, 
					BI.CUSTOMER_NUMBER = TMPTAB.CUSTOMER_NUMBER, 
					BI.SUPPLIER_NUMBER = TMPTAB.SUPPLIER_NUMBER, 
					BI.PRODUCT_NUMBER = TMPTAB.PRODUCT_NUMBER, 
					BI.STOCK_DEPT_NUMBER = TMPTAB.STOCK_DEPT_NUMBER, 
					BI.PO_NUMBER = TMPTAB.PO_NUMBER, 
					BI.LOT_NUMBER = TMPTAB.LOT_NUMBER, 
					BI.LOT_LINE_NUMBER = TMPTAB.LOT_LINE_NUMBER, 
					BI.LOT_PURCHASE_TYPE = TMPTAB.LOT_PURCHASE_TYPE, 
					BI.SALESMAN_NUMBER = TMPTAB.SALESMAN_NUMBER, 
					BI.PACKS_MOVE = TMPTAB.PACKS_MOVE, 
					BI.GROSS_SALEVALUE_MOVE = TMPTAB.GROSS_SALEVALUE_MOVE, 
					BI.REBATE_MOVE = TMPTAB.REBATE_MOVE, 
					BI.DISCOUNT_MOVE = TMPTAB.DISCOUNT_MOVE, 
					BI.OTHER_SALESCOST_MOVE = TMPTAB.OTHER_SALESCOST_MOVE, 
					BI.DELIVERED_GOODS_COST = TMPTAB.DELIVERED_GOODS_COST, 
					BI.NEW_TRANSACTION_FLAG = TMPTAB.NEW_TRANSACTION_FLAG, 
					BI.DELQTYPER = TMPTAB.DELQTYPER, 
					BI.DELRECNO = TMPTAB.DELRECNO, 
					BI.DLVTYPE = TMPTAB.DLVTYPE, 
		  		BI.SALESTYPE = TMPTAB.SALESTYPE, 
					BI.WO_NUMBER = TMPTAB.WO_NUMBER, 
 				  BI.ROUTE_NUMBER = TMPTAB.ROUTE_NUMBER, 
					BI.SALES_PACKS_WEIGHT = TMPTAB.SALES_PACKS_WEIGHT, 
				 	BI.DLVSALTYPE = TMPTAB.DLVSALTYPE, 
					BI.INTERDEPTFLAG = TMPTAB.INTERDEPTFLAG, 
					BI.TRNSALOFFNO = TMPTAB.TRNSALOFFNO, 
					BI.DEPARTMENT = TMPTAB.DEPARTMENT, 
					BI.RECEIVEDDATE = TMPTAB.RECEIVEDDATE, 
          BI.DELPRICEPER = TMPTAB.DELPRICEPER,
          BI.DGPISTPRDNO = TMPTAB.DGPISTPRDNO,
          BI.DROPRTENO = TMPTAB.DROPRTENO,
          BI.SALES_PACKS_MOVE = TMPTAB.SALES_PACKS_MOVE,
					BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
            WHEN NOT MATCHED THEN
			      INSERT(BI.DGPDETAILRECNO, BI.DGPHEDRECNO, BI.DGP_EXTRACTION_DATE, BI.TRANSACTION_NUMBER, BI.DELIVERY_DATE, BI.SALES_OFFICE_NUMBER,
                   BI.DELIVERY_NUMBER, BI.TICKET_NUMBER, BI.INVOICE_NUMBER, BI.CUSTOMER_NUMBER, BI.SUPPLIER_NUMBER,
                   BI.PRODUCT_NUMBER, BI.STOCK_DEPT_NUMBER, BI.PO_NUMBER, BI.LOT_NUMBER, BI.LOT_LINE_NUMBER,
                   BI.LOT_PURCHASE_TYPE, BI.SALESMAN_NUMBER, BI.PACKS_MOVE, BI.GROSS_SALEVALUE_MOVE, BI.REBATE_MOVE,
                   BI.DISCOUNT_MOVE, BI.OTHER_SALESCOST_MOVE, BI.DELIVERED_GOODS_COST, BI.NEW_TRANSACTION_FLAG,
                   BI.DELQTYPER, BI.DELRECNO, BI.DLVTYPE, BI.SALESTYPE, BI.WO_NUMBER, BI.ROUTE_NUMBER, BI.SALES_PACKS_WEIGHT,
                   BI.DLVSALTYPE, BI.INTERDEPTFLAG, BI.TRNSALOFFNO, BI.DEPARTMENT, BI.RECEIVEDDATE, BI.DELPRICEPER, BI.DGPISTPRDNO, BI.DROPRTENO, BI.SALES_PACKS_MOVE, BI.LASTTOUCHEDDATE	)
            VALUES(TMPTAB.TRANSACTION_NUMBER, TMPTAB.DGPHEDRECNO, TMPTAB.DGP_EXTRACTION_DATE, TMPTAB.TRANSACTION_NUMBER, TMPTAB.DELIVERY_DATE, TMPTAB.SALES_OFFICE_NUMBER,
                   TMPTAB.DELIVERY_NUMBER, TMPTAB.TICKET_NUMBER, TMPTAB.INVOICE_NUMBER, TMPTAB.CUSTOMER_NUMBER, TMPTAB.SUPPLIER_NUMBER,
                   TMPTAB.PRODUCT_NUMBER, TMPTAB.STOCK_DEPT_NUMBER, TMPTAB.PO_NUMBER, TMPTAB.LOT_NUMBER, TMPTAB.LOT_LINE_NUMBER,
                   TMPTAB.LOT_PURCHASE_TYPE, TMPTAB.SALESMAN_NUMBER, TMPTAB.PACKS_MOVE, TMPTAB.GROSS_SALEVALUE_MOVE, TMPTAB.REBATE_MOVE,
                   TMPTAB.DISCOUNT_MOVE, TMPTAB.OTHER_SALESCOST_MOVE, TMPTAB.DELIVERED_GOODS_COST, TMPTAB.NEW_TRANSACTION_FLAG,
                   TMPTAB.DELQTYPER, TMPTAB.DELRECNO, TMPTAB.DLVTYPE, TMPTAB.SALESTYPE, TMPTAB.WO_NUMBER, TMPTAB.ROUTE_NUMBER, TMPTAB.SALES_PACKS_WEIGHT,
                   TMPTAB.DLVSALTYPE, TMPTAB.INTERDEPTFLAG, TMPTAB.TRNSALOFFNO, TMPTAB.DEPARTMENT, TMPTAB.RECEIVEDDATE, TMPTAB.DELPRICEPER, TMPTAB.DGPISTPRDNO,
                   TMPTAB.DROPRTENO, TMPTAB.SALES_PACKS_MOVE, TMPTAB.LASTTOUCHEDDATE);
     
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;              
      END IF; 

      IF IN_OPERATIONTYPE = C_DELETE  THEN
      BEGIN
          DELETE FROM BI_DGPDETAILS WHERE DGPHEDRECNO = IN_DGPHEDRECNO;      
      END;
      END IF;
          
            
   COMMIT;
  END PROCESS_DGPDETAILS;  


   /* THIS PROCEDURE TAKES DGPCHARGETAB RECORDS WRITES THEM TO BI_DGPCHARGETAB. CALLED BY PROCESS_DGPHEADER */
   PROCEDURE PROCESS_DGPCHARGETAB (IN_DGPHEDRECNO NUMBER, IN_OPERATIONTYPE VARCHAR2)
   AS   
   BEGIN
   
     IF IN_OPERATIONTYPE = C_CREATE 
     OR IN_OPERATIONTYPE = C_UPDATE THEN    
     BEGIN   
       MERGE INTO BI_DGPCHARGETAB BI  
       USING 
            ( 
				Select DGPCHGRECNO,DGPHEDRECNO,DGPDETRECNO,DGPLITRECNO,DGPDPRRECNO,DGPICHRECNO,
				DGPCHGNO,DGPCHGOPENBASEAPPAMT,DGPCHGCLOSBASEAPPAMT,DGPCHGOPENRAWAPPAMT,
				DGPCHGCLOSRAWAPPAMT,DGPCHGWORECNO,
                sysdate as LASTTOUCHEDDATE
				from DGPCHARGETAB
				Where DGPCHARGETAB.DGPHEDRECNO = IN_DGPHEDRECNO
				) 
               TMPTAB
            ON (BI.DGPCHGRECNO = TMPTAB.DGPCHGRECNO)
            WHEN MATCHED THEN 
                UPDATE SET 
					BI.DGPHEDRECNO = TMPTAB.DGPHEDRECNO,  
					BI.DGPDETRECNO = TMPTAB.DGPDETRECNO,  
					BI.DGPLITRECNO = TMPTAB.DGPLITRECNO,  
					BI.DGPDPRRECNO = TMPTAB.DGPDPRRECNO,  
					BI.DGPICHRECNO = TMPTAB.DGPICHRECNO,  
					BI.DGPCHGNO = TMPTAB.DGPCHGNO,  
					BI.DGPCHGOPENBASEAPPAMT = TMPTAB.DGPCHGOPENBASEAPPAMT,  
					BI.DGPCHGCLOSBASEAPPAMT = TMPTAB.DGPCHGCLOSBASEAPPAMT,  
					BI.DGPCHGOPENRAWAPPAMT = TMPTAB.DGPCHGOPENRAWAPPAMT,  
					BI.DGPCHGCLOSRAWAPPAMT = TMPTAB.DGPCHGCLOSRAWAPPAMT,  
					BI.DGPCHGWORECNO = TMPTAB.DGPCHGWORECNO,  
					BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE
            WHEN NOT MATCHED THEN
			      INSERT(BI.DGPCHGRECNO, BI.DGPHEDRECNO, BI.DGPDETRECNO, BI.DGPLITRECNO, BI.DGPDPRRECNO, BI.DGPICHRECNO, 
				  BI.DGPCHGNO, BI.DGPCHGOPENBASEAPPAMT, BI.DGPCHGCLOSBASEAPPAMT, BI.DGPCHGOPENRAWAPPAMT, BI.DGPCHGCLOSRAWAPPAMT,
				  BI.DGPCHGWORECNO, BI.LASTTOUCHEDDATE	)
            VALUES(TMPTAB.DGPCHGRECNO, TMPTAB.DGPHEDRECNO, TMPTAB.DGPDETRECNO, TMPTAB.DGPLITRECNO, TMPTAB.DGPDPRRECNO, TMPTAB.DGPICHRECNO, 
				  TMPTAB.DGPCHGNO, TMPTAB.DGPCHGOPENBASEAPPAMT, TMPTAB.DGPCHGCLOSBASEAPPAMT, TMPTAB.DGPCHGOPENRAWAPPAMT, TMPTAB.DGPCHGCLOSRAWAPPAMT,
				  TMPTAB.DGPCHGWORECNO, TMPTAB.LASTTOUCHEDDATE);
     
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;              
      END IF; 

      IF IN_OPERATIONTYPE = C_DELETE  THEN
      BEGIN
          DELETE FROM BI_DGPCHARGETAB WHERE DGPHEDRECNO = IN_DGPHEDRECNO;      
      END;
      END IF;
          
            
   COMMIT;
  END PROCESS_DGPCHARGETAB;  

  
  
     /* THIS PROCEDURE TAKES LOOKUP RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO BI_LOOKUPS 
	    Edited for BI TV 5Aug16  */
  PROCEDURE PROCESS_LOOKUPS AS  
  BEGIN
    OPEN LOOKUPS_CUR;
    LOOP
      FETCH LOOKUPS_CUR INTO LOOKUPS_REC;
      
      EXIT WHEN LOOKUPS_CUR%NOTFOUND;
    
      IF LOOKUPS_CUR%FOUND THEN              
      BEGIN 
         /* always going to be a create or edit for lookups */   
        
         MERGE INTO BI_LOOKUPS BI  
         USING 
            ( SELECT  LKUPTABLE, LKUPFIELDNAME, LKUPNO, LKUPDESC, sysdate as LASTTOUCHEDDATE 
              FROM LOOKUPS
              WHERE LKUPTABLE = LOOKUPS_REC.LKUPTABLE
              AND   LKUPFIELDNAME = LOOKUPS_REC.LKUPFIELDNAME
              AND   LKUPNO = LOOKUPS_REC.LKUPNO
               ) 
               TMPTAB
            ON (TMPTAB.LKUPTABLE = BI.LKUPTABLE AND TMPTAB.LKUPFIELDNAME = BI.LKUPFIELDNAME AND TMPTAB.LKUPNO = BI.LKUPNO )
            WHEN MATCHED THEN 
                UPDATE SET BI.LKUPDESC = TMPTAB.LKUPDESC, BI.LASTTOUCHEDDATE = TMPTAB.LASTTOUCHEDDATE 
            WHEN NOT MATCHED THEN
                INSERT(BI.LKUPTABLE, BI.LKUPFIELDNAME, BI.LKUPNO, BI.LKUPDESC, BI.LASTTOUCHEDDATE)
                VALUES(TMPTAB.LKUPTABLE, TMPTAB.LKUPFIELDNAME, TMPTAB.LKUPNO, TMPTAB.LKUPDESC, TMPTAB.LASTTOUCHEDDATE);
    
             DELETE FROM HH_TABLE_LASTUSED 
              WHERE TABLEFLAG     = C_LOOKUPS;
            COMMIT;          
        EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
         END;
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LOOKUPS_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LOOKUPS_CUR%ISOPEN THEN
        CLOSE LOOKUPS_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_LOOKUPS ;
  
  
  /* THIS PROCEDURE CALLS ALL THE REST OF THE REFLAG PROCEDURES  TO RESEND EVERTHING TO THE HH_TABLE_LASTUSED TABLE */
  PROCEDURE REFLAG_ALL IS
  BEGIN
    REFLAG_ALL_DLVTYPE();
    REFLAG_ALL_ACCCLASS();
    REFLAG_ALL_SALOFFNO();
    REFLAG_ALL_ACCTOSALOFF();
    REFLAG_ALL_DEPARTMENTS();
    REFLAG_ALL_DPTTOSALOFFNO();
    REFLAG_ALL_SMN();
    REFLAG_ALL_DEPARTMENTSTOSMN();
    REFLAG_ALL_LOGONS();
    REFLAG_ALL_LOGTOSALOFF();
    REFLAG_ALL_SMNTOLOGON();
    REFLAG_ALL_SOFTOSTCLOC();
    REFLAG_ALL_PRDALLDESCS();     
    REFLAG_ALL_PRDRECS();
    REFLAG_ALL_LOOKUPS();
	
	/* BI specific procedures */
    REFLAG_ALL_ACCCURRDESC();      
    REFLAG_ALL_CHGTYP();           
    REFLAG_ALL_COUNTRY();          
    REFLAG_ALL_CSTANDES();          
    REFLAG_ALL_CSTANGRP();         
	REFLAG_ALL_CSTANREC();          
    REFLAG_ALL_FIXEDROUTES();       
    REFLAG_ALL_HOFCST();            
    REFLAG_ALL_PRDGROUPCAT();      
    REFLAG_ALL_PRDGROUPCATREC();   
    REFLAG_ALL_PRDGROUPGRP();      
    REFLAG_ALL_PRDGROUPGRPREC();   
 	REFLAG_ALL_DOCDISTCONTACTS();
 --   REFLAG_ALL_DGPHEADER(); /* No need to reflag DGPHEADER or DGPDETAILS because they are both populated via this call */	
	 
  END REFLAG_ALL; 
  
  /* GENERIC PROCEDURE - TAKES A CURSOR AND FLAGS ALL TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED */
  PROCEDURE REFLAG_GENERIC(IN_TABLEFLAG NUMBER, IN_CURSOR SYS_REFCURSOR) AS        
   TYPE DATAITEM IS RECORD (
      UNIQNO1     NUMBER(10),
      UNIQNO2     NUMBER(10));
   DATA_REC DATAITEM;
  
  BEGIN  
   LOOP
      FETCH IN_CURSOR INTO DATA_REC;
      EXIT WHEN IN_CURSOR%NOTFOUND;
      BEGIN 
         INSERT_LASTUSED(DATA_REC.UNIQNO1, DATA_REC.UNIQNO2, IN_TABLEFLAG, C_GENERICREFLAGACTION);                
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;          
    END LOOP;    
    COMMIT;
    CLOSE IN_CURSOR;
  EXCEPTION
    WHEN OTHERS THEN
      IF IN_CURSOR%ISOPEN THEN
        CLOSE IN_CURSOR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END REFLAG_GENERIC;

  /* THIS PROCEDURE FLAGS ALL EXISTING PRDREC RECORDS TO BE RE-SENT - IE WRITES TO HH_TABLE_LASTUSED */  
  PROCEDURE REFLAG_ALL_PRDRECS
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT PRDREC.PRCPRDNO AS UNIQNO1, -1 UNIQNO2 FROM PRDREC;
    REFLAG_GENERIC(C_PRDREC, SYS_CUR);
    
  END REFLAG_ALL_PRDRECS;

  /* THIS PROCEDURE FLAGS ALL EXISTING PRDALLDESCS RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/  
  PROCEDURE REFLAG_ALL_PRDALLDESCS
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT PRDALLDESCS.ALLPREFNO AS UNIQNO1, -1 UNIQNO2 FROM PRDALLDESCS;
    REFLAG_GENERIC(C_PRDALLDESCS, SYS_CUR);
    
  END REFLAG_ALL_PRDALLDESCS;
    
  /* THIS PROCEDURE FLAGS ALL EXISTING PRDALLDESCS RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED
  **NOTE** THERE IS NO NEED TO CALL THIS IF REFLAG_ALL_PRDRECS IS CALLED AS THAT WILL SEND ALL PRDRECTOSO RECORDS ANYWAY
  */  
  PROCEDURE REFLAG_ALL_PRDRECTOSO
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT PRDRECTOSO.SALOFFNO AS UNIQNO1, PRCPRDNO UNIQNO2 FROM PRDRECTOSO;
    REFLAG_GENERIC(C_PRDRECTOSO, SYS_CUR);
    
  END REFLAG_ALL_PRDRECTOSO;
    
  /* THIS PROCEDURE FLAGS ALL EXISTING LOGONS RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/  
  PROCEDURE REFLAG_ALL_LOGONS
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT LOGONS.LOGONNO AS UNIQNO1, -1 UNIQNO2 FROM LOGONS  ;
    REFLAG_GENERIC(C_LOGONS , SYS_CUR);
    
  END REFLAG_ALL_LOGONS;
  
  /* THIS PROCEDURE FLAGS ALL EXISTING LOGTOSALOFF RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_LOGTOSALOFF
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR 
       SELECT LOGTOSALOFF.LOGONNO AS UNIQNO1, LOGTOSALOFF.SALOFFNO UNIQNO2 
       FROM LOGTOSALOFF, LOGONS 
       WHERE  LOGTOSALOFF.SALOFFNO > 0 
       AND LOGTOSALOFF.SALOFFNO <32000 
       AND LOGONS.LOGONNO = LOGTOSALOFF.LOGONNO 
       AND LOGONS.ACTIVE = 1;
    REFLAG_GENERIC(C_LOGTOSALOFF , SYS_CUR);
    
  END REFLAG_ALL_LOGTOSALOFF;
  
  /* THIS PROCEDURE FLAGS ALL EXISTING SALOFFNO RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_SALOFFNO
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT SALOFFNO.SALOFFNO AS UNIQNO1, -1 UNIQNO2 FROM SALOFFNO WHERE SALOFFNO.SALOFFNO > 0 AND SALOFFNO.SALOFFNO < 32000  ;
    REFLAG_GENERIC(C_SALOFFNO , SYS_CUR);
    
  END REFLAG_ALL_SALOFFNO;  
   
   /* THIS PROCEDURE FLAGS ALL EXISTING DEPARTMENTS RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_DEPARTMENTS
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT DEPARTMENTS.DPTRECNO AS UNIQNO1, -1 UNIQNO2 FROM DEPARTMENTS ;
    REFLAG_GENERIC(C_DEPARTMENTS , SYS_CUR);
        
  END REFLAG_ALL_DEPARTMENTS;    

  PROCEDURE REFLAG_ALL_DPTTOSALOFFNO
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT Saloffno.Saloffno AS UNIQNO1, DepartmentS.Dptrecno UNIQNO2 
    FROM saloffno, DEPARTMENTS
    WHERE SALOFFNO.SALOFFNO > 0
    AND SALOFFNO.SALOFFNO <32000;
    
    REFLAG_GENERIC(C_DPTTOSALOFFNO , SYS_CUR);
        
  END REFLAG_ALL_DPTTOSALOFFNO;  
 
    /* THIS PROCEDURE FLAGS ALL EXISTING SMN RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_SMN
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT SMN.SMNNO AS UNIQNO1, -1 UNIQNO2 FROM SMN ;
    REFLAG_GENERIC(C_SMN , SYS_CUR);
        
  END REFLAG_ALL_SMN;  
  
  /* THIS PROCEDURE FLAGS ALL EXISTING SMNTOLOGON RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_SMNTOLOGON
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT SMNTOLOGON.SMNNO AS UNIQNO1, SMNTOLOGON.LOGONNO as UNIQNO2 FROM SMNTOLOGON ;
    REFLAG_GENERIC(C_SMNTOLOGON , SYS_CUR);
        
  END REFLAG_ALL_SMNTOLOGON;
 
  /* THIS PROCEDURE FLAGS ALL EXISTING DEPARTMENTSTOSMN RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_DEPARTMENTSTOSMN
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT DEPARTMENTSTOSMN.DPTRECNO as UNIQNO1, DEPARTMENTSTOSMN.SMNNO AS UNIQNO2 FROM DEPARTMENTSTOSMN ;
    REFLAG_GENERIC(C_DEPARTMENTSTOSMN , SYS_CUR);
        
  END REFLAG_ALL_DEPARTMENTSTOSMN;
  
  /* THIS PROCEDURE FLAGS ALL EXISTING SOFTOSTCLOC RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_SOFTOSTCLOC
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT SOFTOSTCLOC.SALOFFNO AS UNIQNO1, SOFTOSTCLOC.STCLOC as UNIQNO2 FROM SOFTOSTCLOC ;
    REFLAG_GENERIC(C_SOFTOSTCLOC , SYS_CUR);
        
  END REFLAG_ALL_SOFTOSTCLOC;
  
 
   /* THIS PROCEDURE FLAGS ALL REQUIRED LOOKUP RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_LOOKUPS
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT -1 AS UNIQNO1, -1 as UNIQNO2 FROM DUAL ;
    REFLAG_GENERIC(C_LOOKUPS , SYS_CUR);
        
  END REFLAG_ALL_LOOKUPS;
  
  
  /* THIS PROCEDURE FLAGS ALL EXISTING ACCCURDESC RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_ACCCURRDESC
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT ACCCURRDESC.CURNO AS UNIQNO1, -1 UNIQNO2 FROM ACCCURRDESC ;
    REFLAG_GENERIC(C_ACCCURRDESC , SYS_CUR);
        
  END REFLAG_ALL_ACCCURRDESC;    
  
  
  /* THIS PROCEDURE FLAGS ALL EXISTING CHGTYP RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_CHGTYP
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT CHGTYP.CTYNO AS UNIQNO1, -1 UNIQNO2 FROM CHGTYP ;
    REFLAG_GENERIC(C_CHGTYP , SYS_CUR);
        
  END REFLAG_ALL_CHGTYP;  
  
  
  /* THIS PROCEDURE FLAGS ALL EXISTING COUNTRY RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_COUNTRY
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT COUNTRY.COUCOURECNO AS UNIQNO1, -1 UNIQNO2 FROM COUNTRY ;
    REFLAG_GENERIC(C_COUNTRY , SYS_CUR);
        
  END REFLAG_ALL_COUNTRY;  
  
  
  /* THIS PROCEDURE FLAGS ALL EXISTING CSTANDES RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_CSTANDES
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT CSTANDES.CSARECNO AS UNIQNO1, -1 UNIQNO2 FROM CSTANDES ;
    REFLAG_GENERIC(C_CSTANDES , SYS_CUR);
        
  END REFLAG_ALL_CSTANDES;  
  
  /* THIS PROCEDURE FLAGS ALL EXISTING CSTANGRP RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_CSTANGRP
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT CSTANGRP.CSGRECNO AS UNIQNO1, -1 UNIQNO2 FROM CSTANGRP ;
    REFLAG_GENERIC(C_CSTANGRP , SYS_CUR);
        
  END REFLAG_ALL_CSTANGRP; 
  
   /* THIS PROCEDURE FLAGS ALL EXISTING CSTANREC RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_CSTANREC
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT CSTANREC.CSDCSGRECNO AS UNIQNO1, CSTANREC.CSDCSTCODE AS UNIQNO2 FROM CSTANREC ;
    REFLAG_GENERIC(C_CSTANREC , SYS_CUR);
        
  END REFLAG_ALL_CSTANREC;  
  
  
  /* THIS PROCEDURE FLAGS ALL EXISTING FIXEDROUTES RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_FIXEDROUTES
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT FIXEDROUTES.FRRECNO AS UNIQNO1, -1 AS UNIQNO2 FROM FIXEDROUTES ;
    REFLAG_GENERIC(C_FIXEDROUTES , SYS_CUR);
        
  END REFLAG_ALL_FIXEDROUTES;  
  
  /* THIS PROCEDURE FLAGS ALL EXISTING HOFCST RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_HOFCST
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT HOFCST.HOFRECNO AS UNIQNO1, HOFCST.CURRENCYCODE AS UNIQNO2 FROM HOFCST ;
    REFLAG_GENERIC(C_HOFCST , SYS_CUR);
        
  END REFLAG_ALL_HOFCST;
  
  /* THIS PROCEDURE FLAGS ALL EXISTING PRDGROUPCAT RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_PRDGROUPCAT
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT PRDGROUPCAT.PRDCATNO AS UNIQNO1, -1 AS UNIQNO2 FROM PRDGROUPCAT ;
    REFLAG_GENERIC(C_PRDGROUPCAT , SYS_CUR);
        
  END REFLAG_ALL_PRDGROUPCAT;
    
  /* THIS PROCEDURE FLAGS ALL EXISTING PRDGROUPCATREC RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_PRDGROUPCATREC
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT PRDGROUPCATREC.PRDCATNO AS UNIQNO1, -1 AS UNIQNO2 FROM PRDGROUPCATREC ;
    REFLAG_GENERIC(C_PRDGROUPCATREC , SYS_CUR);
        
  END REFLAG_ALL_PRDGROUPCATREC;
	
  /* THIS PROCEDURE FLAGS ALL EXISTING PRDGROUPGRP RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_PRDGROUPGRP
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT PRDGROUPGRP.PRDGRPNO AS UNIQNO1, -1 AS UNIQNO2 FROM PRDGROUPGRP ;
    REFLAG_GENERIC(C_PRDGROUPGRP , SYS_CUR);
        
  END REFLAG_ALL_PRDGROUPGRP;
	
  /* THIS PROCEDURE FLAGS ALL EXISTING PRDGROUPGRPREC RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_PRDGROUPGRPREC
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT PRDGROUPGRPREC.PRDGRPNO AS UNIQNO1, PRDGROUPGRPREC.PRDCATNO AS UNIQNO2 FROM PRDGROUPGRPREC ;
    REFLAG_GENERIC(C_PRDGROUPGRPREC , SYS_CUR);
        
  END REFLAG_ALL_PRDGROUPGRPREC;

  /* THIS PROCEDURE FLAGS ALL EXISTING DOCDISTCONTACTS RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_DOCDISTCONTACTS
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT DOCDISTCONTACTS.CONTRECNO AS UNIQNO1, -1 AS UNIQNO2 FROM DOCDISTCONTACTS ;
    REFLAG_GENERIC(C_DOCDISTCONTACTS , SYS_CUR);
        
  END REFLAG_ALL_DOCDISTCONTACTS;  
	
  /* THIS PROCEDURE FLAGS ALL EXISTING DGPHEAD RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_DGPHEADER
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    --OPEN SYS_CUR FOR SELECT DGPHEAD.DGPHEDRECNO AS UNIQNO1, -1 AS UNIQNO2 FROM DGPHEAD
    --    WHERE DGPSALOFFNO = 2 and DGPCLOSED = 1 and DGPHEDRECNO >= 380 ;
        
    OPEN SYS_CUR FOR SELECT DGPHEAD.DGPHEDRECNO AS UNIQNO1, -1 AS UNIQNO2 FROM DGPHEAD
       WHERE dgpsaloffno in (6) 
       AND DGPHEDRECNO NOT in (select DGPHEDRECNO  from BI_DGPHEADER);
      
        
    REFLAG_GENERIC(C_DGPHEADER , SYS_CUR);

  END REFLAG_ALL_DGPHEADER;  
	
		
   /* IF A PRDREC CHANGES THEN ALL THE ASSOC PRDRECTOSO SHOULD BE PROCESSED - THIS PROCEDURE DOES THAT */
  PROCEDURE REFLAG_PRDRECTOSO_FORPRDREC(IN_PRCPRDNO NUMBER, IN_OPERATIONTYPE VARCHAR2)
  AS
    CURSOR PRDRECTOSO_CUR(IN_PRCPRDNO NUMBER)    
    IS
    SELECT DISTINCT SALOFFNO FROM PRDRECTOSO
    WHERE PRCPRDNO = IN_PRCPRDNO;  
    
    PRDRECTOSO_REC       PRDRECTOSO_CUR%ROWTYPE;  

  BEGIN
    
    OPEN PRDRECTOSO_CUR(IN_PRCPRDNO);
    LOOP
      FETCH PRDRECTOSO_CUR INTO PRDRECTOSO_REC;      
      EXIT WHEN PRDRECTOSO_CUR%NOTFOUND;
    
      IF PRDRECTOSO_CUR%FOUND THEN              
      BEGIN 
        INSERT_LASTUSED(PRDRECTOSO_REC.SALOFFNO, IN_PRCPRDNO, C_PRDRECTOSO, IN_OPERATIONTYPE);
      
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE PRDRECTOSO_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF PRDRECTOSO_CUR%ISOPEN THEN
        CLOSE PRDRECTOSO_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
  
  END REFLAG_PRDRECTOSO_FORPRDREC;
  
  
  /* THIS PROCEDURE FLAGS ALL EXISTING Accclass RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_ACCCLASS
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT ACCCLASS.CLARECNO AS UNIQNO1, -1 UNIQNO2 FROM ACCCLASS ;
    REFLAG_GENERIC(C_ACCCLASS , SYS_CUR);
        
  END REFLAG_ALL_ACCCLASS;
  
    /* THIS PROCEDURE FLAGS ALL EXISTING ACCTOSALOFF RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_ACCTOSALOFF
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT ACSCLARECNO AS UNIQNO1, ACSSALOFFNO UNIQNO2 FROM ACCTOSALOFF WHERE ACCTOSALOFF.ACSSALOFFNO > 0 AND ACCTOSALOFF.ACSSALOFFNO < 32000 ;
    REFLAG_GENERIC(C_ACCTOSALOFF , SYS_CUR);
        
  END REFLAG_ALL_ACCTOSALOFF;
  
  
 
 /* THIS PROCEDURE FLAGS ALL EXISTING VATRATES RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_DLVTYPE
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT DLVTYPE.DLTRECNO AS UNIQNO1, -1 UNIQNO2 FROM DLVTYPE WHERE DLVTYPE.DLTRECNO > 0 ;
    REFLAG_GENERIC(C_DLVTYPE , SYS_CUR);
        
  END REFLAG_ALL_DLVTYPE;
  
  
 /* IF A SALOFFNO CHANGES THEN ALL THE ASSOC Departments SHOULD BE PROCESSED - 
    When a DptToSalOffNo table exists in FT this can be got rid of */
  PROCEDURE REFLAG_DPTTOSALOFFNO_S(IN_SALOFFNO NUMBER, IN_OPERATIONTYPE VARCHAR2)
  AS
    CURSOR DPTTOSALOFFNO_CUR    
    IS
    SELECT DISTINCT DPTRECNO FROM DEPARTMENTS; 
    
    DPTTOSALOFFNO_REC       DPTTOSALOFFNO_CUR%ROWTYPE;  

  BEGIN
    
    OPEN DPTTOSALOFFNO_CUR();
    LOOP
      FETCH DPTTOSALOFFNO_CUR INTO DPTTOSALOFFNO_REC;      
      EXIT WHEN DPTTOSALOFFNO_CUR%NOTFOUND;
    
      IF DPTTOSALOFFNO_CUR%FOUND THEN              
      BEGIN 
        INSERT_LASTUSED(IN_SALOFFNO, DPTTOSALOFFNO_REC.DPTRECNO, C_DPTTOSALOFFNO, IN_OPERATIONTYPE);
      
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE DPTTOSALOFFNO_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF DPTTOSALOFFNO_CUR%ISOPEN THEN
        CLOSE DPTTOSALOFFNO_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
  
  END REFLAG_DPTTOSALOFFNO_S;


/* IF A DEPARTMENT CHANGES THEN ALL THE ASSOC SalOffNo SHOULD BE PROCESSED - 
    When a DptToSalOffNo table exists in FT this can be got rid of */
  PROCEDURE REFLAG_DPTTOSALOFFNO_D(IN_DPTRECNO NUMBER, IN_OPERATIONTYPE VARCHAR2)
  AS
    CURSOR SALOFFTODPT_CUR    
    IS
    SELECT DISTINCT SALOFFNO FROM SALOFFNO WHERE SALOFFNO.SALOFFNO > 0 AND SALOFFNO.SALOFFNO < 32000; 
    
    SALOFFTODPT_REC       SALOFFTODPT_CUR%ROWTYPE;  

  BEGIN
    
    OPEN SALOFFTODPT_CUR();
    LOOP
      FETCH SALOFFTODPT_CUR INTO SALOFFTODPT_REC;      
      EXIT WHEN SALOFFTODPT_CUR%NOTFOUND;
    
      IF SALOFFTODPT_CUR%FOUND THEN              
      BEGIN 
        INSERT_LASTUSED(SALOFFTODPT_REC.SALOFFNO, IN_DPTRECNO, C_DPTTOSALOFFNO, IN_OPERATIONTYPE);
      
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE SALOFFTODPT_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF SALOFFTODPT_CUR%ISOPEN THEN
        CLOSE SALOFFTODPT_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
  
  END REFLAG_DPTTOSALOFFNO_D;


  /*  DELETES A RECORD FROM HH_TABLE_LASTUSED 
      Changed TV 19Jul16 to only delete a record if all other flags are set to 0.  Need to edit this if
      the number of flags is ever changed
      TV 1Aug16 Changed the flags for BI*/    
  PROCEDURE DELETE_HH_TABLE_LASTUSED(IN_RECNO1 INTEGER, IN_RECNO2 INTEGER, IN_TABLEFLAG INTEGER, IN_OPERATIONTYPE VARCHAR2, IN_SYSTEMTYPE VARCHAR2 )
  AS
  BEGIN
             -- DELETE FROM HH_TABLE_LASTUSED 
             -- WHERE UNIQUERECNO = IN_RECNO1
             -- AND UNIQUERECNO2  = IN_RECNO2
             -- AND TABLEFLAG     = IN_TABLEFLAG
             -- AND OPERATIONTYPE = IN_OPERATIONTYPE;
              
             MERGE INTO HH_TABLE_LASTUSED HH_LU  
             USING (SELECT IN_RECNO1 UNIQUERECNO , IN_RECNO2 UNIQUERECNO2, IN_TABLEFLAG TABLEFLAG, IN_OPERATIONTYPE OPERATIONTYPE,  SYSDATE LASTUSED FROM DUAL) TMPTAB
             ON (TMPTAB.UNIQUERECNO = HH_LU.UNIQUERECNO
                 AND TMPTAB.UNIQUERECNO2 = HH_LU.UNIQUERECNO2
	               AND TMPTAB.TABLEFLAG = HH_LU.TABLEFLAG
                 )
             WHEN MATCHED THEN 
                UPDATE SET HH_LU.WAITINGFORBI = 0
                DELETE WHERE HH_LU.WAITINGFORHH = 0;
    EXCEPTION
    WHEN OTHERS THEN
      FT_PK_ERRORS.LOG_AND_CONTINUE(); 
            
  END DELETE_HH_TABLE_LASTUSED;
  
  
  /*  SET THIS TO EITHER C, U D BEFORE CALLING REFLAG PROCEDURE AND THE REFLAG WILL USE THIS TO DETERMINE WHAT TO DO
      EG 'C' WILL TREAT ALL REFLAGS AS A CREATE 
  */    
  PROCEDURE SET_GENERICREFLAGACTION(IN_OPERATIONTYPE VARCHAR2)
  AS
  BEGIN
    IF IN_OPERATIONTYPE = C_CREATE           
    OR IN_OPERATIONTYPE = C_UPDATE           
    OR IN_OPERATIONTYPE = C_DELETE            THEN
      C_GENERICREFLAGACTION := IN_OPERATIONTYPE;
    END IF;
  END SET_GENERICREFLAGACTION;
  
  
  
    
 
  
  
END FT_PK_BI ;
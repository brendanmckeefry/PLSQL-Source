create or replace PACKAGE BODY FT_PK_HH
AS

  cVersionControlNo   VARCHAR2(12) := '1.0.5'; -- Current Version Number
  
  --23Nov16 TV Added Received date to HH_ALLOCATE and VAT to Products


 CURSOR LASTUSED_CUR(TABLEFLAG_IN NUMBER, SYSTEM_IN VARCHAR2)    
    IS
    SELECT 	UNIQUERECNO, UNIQUERECNO2, TABLEFLAG, OPERATIONTYPE, LASTUSED
    FROM HH_TABLE_LASTUSED
    WHERE TABLEFLAG = TABLEFLAG_IN
    AND (   (C_HH = SYSTEM_IN AND WAITINGFORHH = 1)
         OR (C_BI = SYSTEM_IN AND WAITINGFORBI = 1)
        ) 
    ORDER BY 1, 2;
  
  LASTUSED_REC       LASTUSED_CUR%ROWTYPE;  
  
  /* This cursor is used to repopulate the Lookups table on the rare occasion it changes
     these are the only records needed to be transferred, so the trigger will only 
     fire when when one changes and then the whole lot are resent */
  /* Changed TV 17May16 to include Credit reasons which are not held in lookups in FT, but are in Handheld
  CURSOR LOOKUPS_CUR    
    IS
    SELECT 	* 
    FROM LOOKUPS
    WHERE  (lkuptable = 'ACCCLASS' and LKUPFIELDNAME = 'CLAACCCSTSUP' and LKUPNO > 0)
    OR    (lkuptable = 'ACCCAT' and LKUPFIELDNAME = 'CLACLASS' and LKUPNO > 0)
    OR    (lkuptable = 'CASHTIKPAY' and LKUPFIELDNAME = 'CSHTIKPAYTYPE' and LKUPNO IN(1,2,3,5))
    ORDER BY 1, 2;
   */
	CURSOR LOOKUPS_CUR    
    IS
    (SELECT LKUPTABLE, LKUPFIELDNAME, LKUPNO, LKUPDESC FROM LOOKUPS
    WHERE  (lkuptable = 'ACCCLASS' and LKUPFIELDNAME = 'CLAACCCSTSUP' and LKUPNO > 0)
    OR    (lkuptable = 'ACCCAT' and LKUPFIELDNAME = 'CLACLASS' and LKUPNO IN (5,6,8,11))
    OR    (lkuptable = 'CASHTIKPAY' and LKUPFIELDNAME = 'CSHTIKPAYTYPE' and LKUPNO IN(1,2,3,5)))
    union
    (select 'CDSSTKADJ' as LKUPTABLE, 'CDSADJSTOCK' as LKUPFIELDNAME, CDSREFNO as LKUPNO, CDSDESCRIPTION as LKUPDESC  from CDSTKADJ
    WHERE CDSADJUSTSTK = 1 and CDSREFNO > 0
    )
    union
    (select 'CDSSTKADJ' as LKUPTABLE, 'CDSNOTADJSTOCK' as LKUPFIELDNAME, CDSREFNO as LKUPNO, CDSDESCRIPTION as LKUPDESC  from CDSTKADJ
    WHERE CDSADJUSTSTK = 0 and CDSREFNO > 0
    )
    ORDER BY 1, 2;	
	
    LOOKUPS_REC       LOOKUPS_CUR%ROWTYPE;  
  

  FUNCTION CURRENTVERSION(IN_BODYORSPEC IN INTEGER ) RETURN VARCHAR2
  IS
  BEGIN
    IF  IN_BODYORSPEC = CONST.C_SPEC THEN
         RETURN cSpecVersionControlNo;
    ELSE  
        RETURN cVersionControlNo;
    END IF;        
        
  END CURRENTVERSION;
 
  PROCEDURE INSERT_LASTUSED(IN_RECNO1 INTEGER, IN_RECNO2 INTEGER, IN_TABLEFLAG INTEGER, IN_OPERATIONTYPE VARCHAR2 ) AS
  BEGIN
    -- Called from triggers on tables that are needed in the Hand Held module
    -- This populates HH_TABLE_LASTUSED with keys of changed records
    -- BSDL14496 TPUK TV 22Jul15
    MERGE INTO HH_TABLE_LASTUSED HH_LU  
    USING (SELECT IN_RECNO1 UNIQUERECNO , IN_RECNO2 UNIQUERECNO2, IN_TABLEFLAG TABLEFLAG, IN_OPERATIONTYPE OPERATIONTYPE,  SYSDATE LASTUSED FROM DUAL) TMPTAB
    ON (TMPTAB.UNIQUERECNO = HH_LU.UNIQUERECNO
        AND TMPTAB.UNIQUERECNO2 = HH_LU.UNIQUERECNO2
	      AND TMPTAB.TABLEFLAG = HH_LU.TABLEFLAG)
    WHEN MATCHED THEN 
        UPDATE SET HH_LU.OPERATIONTYPE = TMPTAB.OPERATIONTYPE, HH_LU.LASTUSED = TMPTAB.LASTUSED,  HH_LU.WAITINGFORHH = DEFAULT, HH_LU.WAITINGFORBI = DEFAULT
    WHEN NOT MATCHED THEN
        INSERT(HH_LU.UNIQUERECNO, HH_LU.UNIQUERECNO2, HH_LU.TABLEFLAG, HH_LU.OPERATIONTYPE, HH_LU.LASTUSED)
	      VALUES(TMPTAB.UNIQUERECNO, TMPTAB.UNIQUERECNO2, TMPTAB.TABLEFLAG, TMPTAB.OPERATIONTYPE, TMPTAB.LASTUSED);
   EXCEPTION
    WHEN OTHERS THEN
      FT_PK_ERRORS.LOG_AND_CONTINUE;
  END INSERT_LASTUSED;

  /*  THIS PROCEDURE CALLS ALL THE OTHER PROCESS_***** PROCEDURES AND TAKES CHANGED RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO THE TRANSFER TABLE  
      This needs to be in this order because of referential integrity on the tables*/
  PROCEDURE PROCESS_ALL IS
  BEGIN
    /*(17)*/ PROCESS_DLVTYPE();
    /*(14)*/ PROCESS_ACCCLASS();
    /*(16)*/ PROCESS_ACCCAT();
     /*(5)*/ PROCESS_SALOFFNO();
    /*(15)*/ PROCESS_ACCTOSALOFF();
     /*(6)*/ PROCESS_DEPARTMENTS();
     /*(7)*/ PROCESS_DPTTOSALOFFNO();
     /*(8)*/ PROCESS_SMN();
    /*(10)*/ PROCESS_DEPARTMENTSTOSMN();
     /*(3)*/ PROCESS_LOGONS();
     /*(4)*/ PROCESS_LOGTOSALOFF();
     /*(9)*/ PROCESS_SMNTOLOGON();
    /*(11)*/ PROCESS_SOFTOSTCLOC();
     /*(2)*/ PROCESS_PRDALLDESCS();
     /*(1)*/ PROCESS_PRDRECS();   
    /*(12)*/ PROCESS_PRDRECTOSO();
    /*(13)*/ PROCESS_VATRATES();
    /*(19)*/ PROCESS_ALLOCATE();
    /*(18)*/ PROCESS_LOOKUPS();
     
    /*(22) PROCESS_LOTITE(); */
    /*(28) PROCESS_TKTBK();needs changing */
    /*(29) PROCESS_TKTNT(); no longer required */
    
    /*(34)*/ PROCESS_HH_GUID();
	
	/* This gets rid of records not needed by HH but needed by BI */
	PROCESS_NOT_NEEDED_FILES(C_ACCCURRDESC, C_HH); 
	PROCESS_NOT_NEEDED_FILES(C_CHGTYP, C_HH); 
	PROCESS_NOT_NEEDED_FILES(C_COUNTRY, C_HH); 
	PROCESS_NOT_NEEDED_FILES(C_CSTANDES, C_HH); 
	PROCESS_NOT_NEEDED_FILES(C_CSTANGRP, C_HH); 
	PROCESS_NOT_NEEDED_FILES(C_CSTANREC, C_HH); 
	PROCESS_NOT_NEEDED_FILES(C_FIXEDROUTES, C_HH); 
	PROCESS_NOT_NEEDED_FILES(C_HOFCST, C_HH); 
	PROCESS_NOT_NEEDED_FILES(C_PRDGROUPCAT, C_HH); 
	PROCESS_NOT_NEEDED_FILES(C_PRDGROUPCATREC, C_HH); 
	PROCESS_NOT_NEEDED_FILES(C_PRDGROUPGRP, C_HH); 
	PROCESS_NOT_NEEDED_FILES(C_PRDGROUPGRPREC, C_HH); 
  PROCESS_NOT_NEEDED_FILES(C_DOCDISTCONTACTS, C_HH); 
	PROCESS_NOT_NEEDED_FILES(C_DGPHEADER, C_HH); 


  END PROCESS_ALL; 
  
  /* THIS PROCEDURE TAKES PRDREC RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_PRDREC */
  PROCEDURE PROCESS_PRDRECS AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_PRDREC, C_HH);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO HH_PRDREC HH  
              USING 
              (SELECT PRCPRDNO, PRCREF1, PRCREF2,PRCREF3,PRCREF4,PRCREF5,PRCREF6,PRCDESCRIPTION,PRCPRDREF,ACTIVE,
                      FT_PK_HH.GETVATFORPRODUCT(PRCPRDNO,-32000) AS PRCVATCODE
                  FROM PRDREC
                  WHERE PRCPRDNO = LASTUSED_REC.UNIQUERECNO) 
                  TMPTAB
              ON (TMPTAB.PRCPRDNO = HH.PRCPRDNO)
              WHEN MATCHED THEN 
                  UPDATE SET  HH.PRCREF1 = TMPTAB.PRCREF1, 
                              HH.PRCREF2 = TMPTAB.PRCREF2, 
                              HH.PRCREF3 = TMPTAB.PRCREF3, 
                              HH.PRCREF4 = TMPTAB.PRCREF4,
                              HH.PRCREF5 = TMPTAB.PRCREF5, 
                              HH.PRCREF6 = TMPTAB.PRCREF6, 
                              HH.PRCDESCRIPTION = TMPTAB.PRCDESCRIPTION, 
                              HH.PRCVATCODE = TMPTAB.PRCVATCODE, 
                              HH.PRCPRDREF = TMPTAB.PRCPRDREF, 
                              HH.ACTIVE = TMPTAB.ACTIVE
              WHEN NOT MATCHED THEN
                  INSERT(HH.PRCPRDNO, HH.PRCREF1, HH.PRCREF2, HH.PRCREF3, HH.PRCREF4, HH.PRCREF5, HH.PRCREF6, HH.PRCDESCRIPTION, HH.PRCVATCODE, HH.PRCPRDREF, HH.ACTIVE)
                  VALUES(TMPTAB.PRCPRDNO, TMPTAB.PRCREF1, TMPTAB.PRCREF2, TMPTAB.PRCREF3, TMPTAB.PRCREF4, TMPTAB.PRCREF5, TMPTAB.PRCREF6, TMPTAB.PRCDESCRIPTION, TMPTAB.PRCVATCODE, TMPTAB.PRCPRDREF, TMPTAB.ACTIVE);
              END;
            END IF;
                  
              -- THIS SHOULDNEVER HAPPEN AS A PRDPREC IS NEVER DELETED BUT WE'LL STICK IT IN 
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM HH_PRDREC WHERE PRCPRDNO = LASTUSED_REC.UNIQUERECNO;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_HH);
            
            -- SEND ALL THE PRDRECTOSO RECORDS 
            REFLAG_PRDRECTOSO_FORPRDREC(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.OPERATIONTYPE);
           
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_PRDRECS;
     
  /* THIS PROCEDURE TAKES PRDALLDESCS RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_PRDALLDESCS */
  PROCEDURE PROCESS_PRDALLDESCS AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_PRDALLDESCS, C_HH);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO HH_PRDALLDESCS HH  
              USING 
              (SELECT ALLPREFNO, ALLPLEVNO, ALLPDESC, ALLPCODE, NVL(ACTIVE,0) AS ACTIVE, NVL(UNDEFINED,0) as UNDEFINED  
                  FROM PRDALLDESCS
                  WHERE ALLPREFNO = LASTUSED_REC.UNIQUERECNO) 
                  TMPTAB
              ON (TMPTAB.ALLPREFNO = HH.ALLPREFNO)
              WHEN MATCHED THEN 
                  UPDATE SET  HH.ALLPLEVNO = TMPTAB.ALLPLEVNO, 
                              HH.ALLPDESC = TMPTAB.ALLPDESC, 
                              HH.ALLPCODE = TMPTAB.ALLPCODE,
                              HH.ACTIVE = TMPTAB.ACTIVE,
                              HH.UNDEFINED = TMPTAB.UNDEFINED
              WHEN NOT MATCHED THEN
                  INSERT(HH.ALLPREFNO, HH.ALLPLEVNO, HH.ALLPDESC, HH.ALLPCODE,  HH.ACTIVE, HH.UNDEFINED    )
                  VALUES(TMPTAB.ALLPREFNO, TMPTAB.ALLPLEVNO, TMPTAB.ALLPDESC, TMPTAB.ALLPCODE,  TMPTAB.ACTIVE, TMPTAB.UNDEFINED);
              END;
            END IF;
                  
              -- THIS SHOULD NEVER HAPPEN AS A PRDALLDESCS IS NEVER DELETED BUT WE'LL STICK IT IN 
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM HH_PRDALLDESCS WHERE ALLPREFNO = LASTUSED_REC.UNIQUERECNO;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_HH);
                       
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_PRDALLDESCS;
  
  /* THIS PROCEDURE TAKES PRDRECTOSO RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_PRDRECTOSO */
  PROCEDURE PROCESS_PRDRECTOSO AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_PRDRECTOSO, C_HH);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO HH_PRDRECTOSO HH  
              USING 
              (
              SELECT PRDRECTOSO.SALOFFNO, PRDRECTOSO.PRCPRDNO, PRDRECTOSO.SOSHORTCODE,
              SHORTCODEDEFAULT.SHORTCODEDESCRIPTION,
              NVL(PRDREC.PRCSALBYBOX,0) as PRCSALBYBOX, NVL(PRDREC.PRCSALBYEACH,0) as PRCSALBYEACH, NVL(PRDREC.PRCSALBYINNER,0) as PRCSALBYINNER, NVL(PRDREC.PRCSALBYWGT,0) as PRCSALBYWGT, 
              PRDREC.PRCWEIGHT, PRDREC.INNERQTY, PRDREC.PRCBOXQTY, NVL(PRDREC.DEFAULTPRD,0) as DEFAULTPRD, 
              FT_PK_HH.GETVATFORPRODUCT(PRDRECTOSO.PRCPRDNO,PRDRECTOSO.SALOFFNO) AS VATRECNO
              FROM PRDRECTOSO, SHORTCODEDEFAULT, PRDREC
              WHERE PRDRECTOSO.SOSHORTCODE = SHORTCODEDEFAULT.SHORTCODE(+)
              AND   PRDRECTOSO.SALOFFNO = SHORTCODEDEFAULT.SALESOFFICE(+)
              AND   PRDRECTOSO.PRCPRDNO = PRDREC.PRCPRDNO 
              AND   PRDRECTOSO.SALOFFNO   = LASTUSED_REC.UNIQUERECNO
              AND   PRDRECTOSO.PRCPRDNO = LASTUSED_REC.UNIQUERECNO2
              ) 
                  TMPTAB
              ON (
                TMPTAB.SALOFFNO = HH.SALOFFNO
                AND TMPTAB.PRCPRDNO = HH.PRCPRDNO              
              )
              WHEN MATCHED THEN 
                  UPDATE SET  HH.SOSHORTCODE = TMPTAB.SOSHORTCODE, 
                              HH.SHORTCODEDESCRIPTION = TMPTAB.SHORTCODEDESCRIPTION, 
                              HH.PRCSALBYBOX = TMPTAB.PRCSALBYBOX,
                              HH.PRCSALBYEACH = TMPTAB.PRCSALBYEACH,
                              HH.PRCSALBYINNER = TMPTAB.PRCSALBYINNER,
                              HH.PRCSALBYWGT = TMPTAB.PRCSALBYWGT,
                              HH.INNERQTY = TMPTAB.INNERQTY,
                              HH.PRCBOXQTY = TMPTAB.PRCBOXQTY,
                              HH.DEFAULTPRD = TMPTAB.DEFAULTPRD,
                              HH.VATRECNO = TMPTAB.VATRECNO
              WHEN NOT MATCHED THEN
                  INSERT(HH.SALOFFNO, HH.PRCPRDNO, HH.SOSHORTCODE, HH.SHORTCODEDESCRIPTION, HH.PRCSALBYBOX, HH.PRCSALBYEACH, HH.PRCSALBYINNER, HH.PRCSALBYWGT, 
                          HH.PRCWEIGHT, HH.INNERQTY, HH.PRCBOXQTY, HH.DEFAULTPRD, HH.VATRECNO)
                  VALUES(TMPTAB.SALOFFNO, TMPTAB.PRCPRDNO, TMPTAB.SOSHORTCODE, TMPTAB.SHORTCODEDESCRIPTION, TMPTAB.PRCSALBYBOX, TMPTAB.PRCSALBYEACH, TMPTAB.PRCSALBYINNER, TMPTAB.PRCSALBYWGT, 
                          TMPTAB.PRCWEIGHT, TMPTAB.INNERQTY, TMPTAB.PRCBOXQTY, TMPTAB.DEFAULTPRD, TMPTAB.VATRECNO  );
              END;
            END IF;
                  
              -- THIS SHOULD NEVER HAPPEN AS A PRDALLDESCS IS NEVER DELETED BUT WE'LL STICK IT IN 
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM HH_PRDRECTOSO WHERE SALOFFNO = LASTUSED_REC.UNIQUERECNO
              AND   PRCPRDNO = LASTUSED_REC.UNIQUERECNO2
              ;                                       
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_HH);            
            
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_PRDRECTOSO;
  
  /* THIS PROCEDURE TAKES LOGONS RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_LOGONS */
  PROCEDURE PROCESS_LOGONS AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_LOGONS, C_HH);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO HH_LOGONS HH  
              USING 
              (SELECT LOGONNO, LOGONNAME,  USERNAME  FROM LOGONS
                  WHERE LOGONNO = LASTUSED_REC.UNIQUERECNO
                  --AND  = LASTUSED_REC.UNIQUERECNO2
                  ) 
                  TMPTAB
              ON (TMPTAB.LOGONNO = HH.LOGONNO)
              WHEN MATCHED THEN 
                  UPDATE SET  HH.LOGONNAME = TMPTAB.LOGONNAME, 
                              HH.USERNAME = TMPTAB.USERNAME
              WHEN NOT MATCHED THEN
                  INSERT(HH.LOGONNO, HH.LOGONNAME,  HH.USERNAME)
                  VALUES(TMPTAB.LOGONNO, TMPTAB.LOGONNAME,  TMPTAB.USERNAME);
              END;
            END IF;
                  
              -- THIS SHOULD NEVER HAPPEN AS A PRDALLDESCS IS NEVER DELETED BUT WE'LL STICK IT IN 
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM HH_LOGONS WHERE LOGONNO = LASTUSED_REC.UNIQUERECNO
              --AND    = LASTUSED_REC.UNIQUERECNO2              
              ;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_HH);            
            
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_LOGONS ;
 
  /* This procedure is called to cleardown all records in HH_TABLE_LASTUSED where the table is not transferred, hence the records will
     otherwise hang around for ever 
	 TV 5Aug16 */  
  PROCEDURE PROCESS_NOT_NEEDED_FILES(IN_TABLEFLAG NUMBER, IN_SYSTEMTYPE VARCHAR2) AS
  BEGIN
    
    OPEN LASTUSED_CUR(IN_TABLEFLAG, IN_SYSTEMTYPE);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
         DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, IN_SYSTEMTYPE);            
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_NOT_NEEDED_FILES;

  
 
  
  /* THIS PROCEDURE TAKES LOGTOSALOFF RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_LOGTOSALOFF */
  PROCEDURE PROCESS_LOGTOSALOFF AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_LOGTOSALOFF, C_HH );
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              INSERT INTO HH_LOGTOSALOFF(LOGONNO, SALOFFNO)
              (SELECT LOGONNO, SALOFFNO FROM LOGTOSALOFF
                WHERE LOGONNO = LASTUSED_REC.UNIQUERECNO
                  AND SALOFFNO = LASTUSED_REC.UNIQUERECNO2
                  AND NOT EXISTS ( SELECT 1 FROM HH_LOGTOSALOFF
                                  WHERE HH_LOGTOSALOFF.LOGONNO = LOGTOSALOFF.LOGONNO
                                  AND HH_LOGTOSALOFF.SALOFFNO = LOGTOSALOFF.SALOFFNO)
                );
                END;
            END IF;
                  
              -- THIS SHOULD NEVER HAPPEN AS A PRDALLDESCS IS NEVER DELETED BUT WE'LL STICK IT IN 
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM HH_LOGTOSALOFF WHERE LOGONNO = LASTUSED_REC.UNIQUERECNO
              AND   SALOFFNO  = LASTUSED_REC.UNIQUERECNO2              
              ;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_HH);
            
            COMMIT;           
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_LOGTOSALOFF ;

  /* THIS PROCEDURE TAKES SALOFFNO RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_SALOFFNO */
  PROCEDURE PROCESS_SALOFFNO AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_SALOFFNO, C_HH);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO HH_SALOFFNO HH  
              USING 
              ( SELECT SALOFFNO, SALOFFDESC, COMPADD1, COMPADD2, COMPADD3, COMPADD4, POSTCODE, COMPPHONE, COMPFAX, COMPVATNO FROM SALOFFNO
                  WHERE SALOFFNO = LASTUSED_REC.UNIQUERECNO
                  --AND *-*-* = LASTUSED_REC.UNIQUERECNO2
                  ) 
                  TMPTAB
              ON (TMPTAB.SALOFFNO = HH.SALOFFNO)
              WHEN MATCHED THEN 
                  UPDATE SET  HH.SALOFFDESC = TMPTAB.SALOFFDESC,
				              HH.ADDRESS1   = TMPTAB.COMPADD1, 
				              HH.ADDRESS2   = TMPTAB.COMPADD2, 
				              HH.ADDRESS3   = TMPTAB.COMPADD3, 
				              HH.ADDRESS4   = TMPTAB.COMPADD4, 
				              HH.POSTCODE   = TMPTAB.POSTCODE, 
							  HH.PHONENO    = TMPTAB.COMPPHONE,
							  HH.FAXNO      = TMPTAB.COMPFAX,
							  HH.VATNUMBER  = TMPTAB.COMPVATNO
              WHEN NOT MATCHED THEN
                  INSERT(HH.SALOFFNO, HH.SALOFFDESC, HH.ADDRESS1,  HH.ADDRESS2, HH.ADDRESS3, HH.ADDRESS4, 
				         HH.POSTCODE, HH.PHONENO, HH.FAXNO, HH.VATNUMBER)
                  VALUES(TMPTAB.SALOFFNO,  TMPTAB.SALOFFDESC, TMPTAB.COMPADD1, TMPTAB.COMPADD2, TMPTAB.COMPADD3, TMPTAB.COMPADD4,
   				         TMPTAB.POSTCODE, TMPTAB.COMPPHONE, TMPTAB.COMPFAX, TMPTAB.COMPVATNO );
              END;
            END IF;
                  
              -- THIS SHOULD NEVER HAPPEN AS A PRDALLDESCS IS NEVER DELETED BUT WE'LL STICK IT IN 
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM HH_SALOFFNO WHERE SALOFFNO = LASTUSED_REC.UNIQUERECNO
              --AND   *-*-*  = LASTUSED_REC.UNIQUERECNO2              
              ;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_HH);
         
            /* There is no DPTTOSALOFFNO table in Freshtrade, so need to reflag every
               time the sales office changes
            */
            REFLAG_DPTTOSALOFFNO_S(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.OPERATIONTYPE);
                      
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_SALOFFNO ;

  /* THIS PROCEDURE TAKES DEPARTMENTS RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_DEPARTMENTS */
  PROCEDURE PROCESS_DEPARTMENTS AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_DEPARTMENTS,C_HH);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO HH_DEPARTMENTS HH  
              USING 
              ( SELECT DPTRECNO, DPT_DESC FROM DEPARTMENTS
                  WHERE DPTRECNO = LASTUSED_REC.UNIQUERECNO
                  --AND *-*-* = LASTUSED_REC.UNIQUERECNO2
                  ) 
                  TMPTAB
              ON (TMPTAB.DPTRECNO = HH.DPTRECNO)
              WHEN MATCHED THEN 
                  UPDATE SET  HH.DPT_DESC = TMPTAB.DPT_DESC
              WHEN NOT MATCHED THEN
                  INSERT(HH.DPTRECNO, HH.DPT_DESC )
                  VALUES(TMPTAB.DPTRECNO,  TMPTAB.DPT_DESC );
              END;
            END IF;
                  
              -- THIS SHOULD NEVER HAPPEN AS A PRDALLDESCS IS NEVER DELETED BUT WE'LL STICK IT IN 
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM HH_DEPARTMENTS WHERE DPTRECNO = LASTUSED_REC.UNIQUERECNO
              --AND   *-*-*  = LASTUSED_REC.UNIQUERECNO2              
              ;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_HH);
            
            /* There is no DPTTOSALOFFNO table in Freshtrade, so need to reflag every
               time the sales office changes
            */
            REFLAG_DPTTOSALOFFNO_D(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.OPERATIONTYPE);
            
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_DEPARTMENTS ;
  
   /* THIS PROCEDURE TAKES DPTTOSALOFFNO RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_DPTTOSALOFFNO */
  PROCEDURE PROCESS_DPTTOSALOFFNO AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_DPTTOSALOFFNO,C_HH);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              INSERT INTO HH_DPTTOSALOFFNO(SALOFFNO, DPTRECNO)
              (SELECT LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2 FROM DUAL
                WHERE NOT EXISTS ( SELECT 1 FROM HH_DPTTOSALOFFNO
                                  WHERE HH_DPTTOSALOFFNO.SALOFFNO = LASTUSED_REC.UNIQUERECNO
                                  AND HH_DPTTOSALOFFNO.DPTRECNO = LASTUSED_REC.UNIQUERECNO2)
                                  )
                                  ;
              END;
            END IF;
                  
              -- THIS SHOULD NEVER HAPPEN AS A PRDALLDESCS IS NEVER DELETED BUT WE'LL STICK IT IN 
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM HH_DPTTOSALOFFNO WHERE SALOFFNO = LASTUSED_REC.UNIQUERECNO
              AND   DPTRECNO  = LASTUSED_REC.UNIQUERECNO2              
              ;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_HH);
            commit;           
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_DPTTOSALOFFNO ;
  
   /* THIS PROCEDURE TAKES SMN RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_SMN */
  PROCEDURE PROCESS_SMN AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_SMN,C_HH);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO HH_SMN HH  
              USING 
              ( SELECT SMNNO, SMNTYPE,SMNNAME FROM SMN
                  WHERE SMNNO = LASTUSED_REC.UNIQUERECNO
                  --AND *-*-* = LASTUSED_REC.UNIQUERECNO2
                  ) 
                  TMPTAB
              ON (TMPTAB.SMNNO = HH.SMNNO)
              WHEN MATCHED THEN 
                  UPDATE SET  HH.SMNTYPE = TMPTAB.SMNTYPE, HH.SMNNAME = TMPTAB.SMNNAME 
              WHEN NOT MATCHED THEN
                  INSERT(HH.SMNNO, HH.SMNTYPE,HH.SMNNAME )
                  VALUES(TMPTAB.SMNNO,  TMPTAB.SMNTYPE, TMPTAB.SMNNAME );
              END;
            END IF;
                  
              -- THIS SHOULD NEVER HAPPEN AS A SMN IS NEVER DELETED BUT WE'LL STICK IT IN 
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM HH_SMN WHERE SMNNO = LASTUSED_REC.UNIQUERECNO;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_HH);
            
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_SMN ; 
  
  /* THIS PROCEDURE TAKES SMNTOLOGON RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_SMNTOLOGON 
     The handheld software requires that each user is only linked to one saleman,  Therefore, in
     case two or more salesmen are added in FT, the maximum salesman record will always be used
     and this will be the record updated regardless of the salesman actually flagged in the 
     lastused table! TV 22Oct15*/
  PROCEDURE PROCESS_SMNTOLOGON AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_SMNTOLOGON, C_HH);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO HH_SMNTOLOGON HH  
              USING 
              ( SELECT MAX(SMNNO) AS SMNNO, LOGONNO FROM SMNTOLOGON
                  WHERE LOGONNO = LASTUSED_REC.UNIQUERECNO2
                  group by logonno
                  ) 
                  TMPTAB
              ON (TMPTAB.SMNNO = HH.SMNNO AND TMPTAB.LOGONNO = HH.LOGONNO)

              WHEN NOT MATCHED THEN
                  INSERT(HH.SMNNO, HH.LOGONNO )
                  VALUES(TMPTAB.SMNNO,  TMPTAB.LOGONNO );
              END;
              
              /* Tidy up any old lower valued salesmen */
              DELETE FROM HH_SMNTOLOGON 
                 WHERE LOGONNO = LASTUSED_REC.UNIQUERECNO2 
                 AND SMNNO <>  (SELECT MAX(S2.SMNNO) FROM SMNTOLOGON S2 WHERE S2.LOGONNO = LASTUSED_REC.UNIQUERECNO2);   
              
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM HH_SMNTOLOGON WHERE SMNNO = LASTUSED_REC.UNIQUERECNO and LOGONNO = LASTUSED_REC.UNIQUERECNO2;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_HH);
            
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_SMNTOLOGON ; 
  
    /* THIS PROCEDURE TAKES DEPARTMENTSTOSMN RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_DEPARTMENTSTOSMN */
  PROCEDURE PROCESS_DEPARTMENTSTOSMN AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_DEPARTMENTSTOSMN, C_HH);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO HH_DEPARTMENTSTOSMN HH  
              USING 
              ( SELECT SMNNO, DPTRECNO FROM DEPARTMENTSTOSMN
                  WHERE SMNNO = LASTUSED_REC.UNIQUERECNO2
                  AND DPTRECNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.SMNNO = HH.SMNNO AND TMPTAB.DPTRECNO = HH.DPTRECNO)

              WHEN NOT MATCHED THEN
                  INSERT(HH.SMNNO, HH.DPTRECNO )
                  VALUES(TMPTAB.SMNNO,  TMPTAB.DPTRECNO );
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM HH_DEPARTMENTSTOSMN WHERE SMNNO = LASTUSED_REC.UNIQUERECNO2 and DPTRECNO = LASTUSED_REC.UNIQUERECNO;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_HH);
            
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_DEPARTMENTSTOSMN ;  
  
  /* THIS PROCEDURE TAKES SOFTOSTCLOC RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_SOFTOSTCLOC 
    In order to make sure that there is only one stock location per sales office, the extraction
    checks the DefStcLoc field and ignores the change if the record is not the default
    TV 22Oct15 */
  PROCEDURE PROCESS_SOFTOSTCLOC AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_SOFTOSTCLOC, C_HH);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO HH_SOFTOSTCLOC HH  
              USING 
              ( SELECT SOFTOSTCLOC.SALOFFNO, SOFTOSTCLOC.STCLOC, STOCLOC.STCLOCDESC as STCLOCNAME 
                  FROM SOFTOSTCLOC, STOCLOC
                  WHERE SOFTOSTCLOC.SALOFFNO = LASTUSED_REC.UNIQUERECNO
                  AND SOFTOSTCLOC.STCLOC = LASTUSED_REC.UNIQUERECNO2
                  AND SOFTOSTCLOC.DEFSTCLOC = 1
                  AND SOFTOSTCLOC.STCLOC = STOCLOC.STCRECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.SALOFFNO = HH.SALOFFNO AND TMPTAB.STCLOC = HH.STCLOC)
              WHEN MATCHED THEN 
                  UPDATE SET  HH.STCLOCNAME = TMPTAB.STCLOCNAME 
              WHEN NOT MATCHED THEN
                  INSERT(HH.SALOFFNO, HH.STCLOC, HH.STCLOCNAME )
                  VALUES(TMPTAB.SALOFFNO,  TMPTAB.STCLOC, TMPTAB.STCLOCNAME );
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM HH_SOFTOSTCLOC WHERE SALOFFNO = LASTUSED_REC.UNIQUERECNO and STCLOC = LASTUSED_REC.UNIQUERECNO2;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_HH);
            
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_SOFTOSTCLOC ; 
  
  /* THIS PROCEDURE TAKES VatRates RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_VatRates */
  PROCEDURE PROCESS_VATRATES AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_VATRATES, C_HH);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO HH_VATRATES HH  
              USING 
              ( SELECT VATRECNO, VATDESC, VATRATE FROM VATRATES
                  WHERE VATRECNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.VATRECNO = HH.VATRECNO)
              WHEN MATCHED THEN 
                  UPDATE SET  HH.VATDESC = TMPTAB.VATDESC, HH.VATRATE = TMPTAB.VATRATE
              WHEN NOT MATCHED THEN
                  INSERT(HH.VATRECNO, HH.VATDESC, HH.VATRATE )
                  VALUES(TMPTAB.VATRECNO,  TMPTAB.VATDESC, TMPTAB.VATRATE );
              END;
            END IF;
                  
              -- THIS SHOULD NEVER HAPPEN AS A VATRATES IS NEVER DELETED BUT WE'LL STICK IT IN 
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM HH_VATRATES WHERE VATRECNO = LASTUSED_REC.UNIQUERECNO
              --AND   *-*-*  = LASTUSED_REC.UNIQUERECNO2              
              ;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_HH);
                      
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_VATRATES ;
  
  /* THIS PROCEDURE TAKES ACCCLASS RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_ACCCLASS 
     TV 21Oct15 Added address and postcode 
     TV 19Jan16 Added InterDeptCust */
  PROCEDURE PROCESS_ACCCLASS AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_ACCCLASS, C_HH);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO HH_ACCCLASS HH  
              USING 
              ( SELECT CLARECNO, CLAACCCSTSUP, CLAACCCODE, CLAACTIVE, CLACONTACTNAME, ACCNAME, CASHCUSTOMER, DEFDLTRECNO,
                  ACCADDRESS1, ACCADDRESS2, ACCADDRESS3, ACCADDRESS4, ACCPOSTCODE, ACCOUNTS.INTERDEPTCUST
                  FROM ACCCLASS
                  INNER JOIN ACCOUNTS ON ACCCLASS.CLAACCCODE = ACCOUNTS.ACCCODE
                  WHERE CLARECNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.CLARECNO = HH.CLARECNO)
              WHEN MATCHED THEN 
                  UPDATE SET  HH.CLAACCCSTSUP =TMPTAB.CLAACCCSTSUP, HH.CLAACCCODE = TMPTAB.CLAACCCODE, HH.CLAACTIVE = TMPTAB.CLAACTIVE, 
                  HH.CLACONTACTNAME = TMPTAB.CLACONTACTNAME, HH.ACCNAME = TMPTAB.ACCNAME, HH.CASHCUSTOMER = TMPTAB.CASHCUSTOMER, HH.DEFDLTRECNO = TMPTAB.DEFDLTRECNO,
                  HH.ACCADDRESS1 = TMPTAB.ACCADDRESS1, HH.ACCADDRESS2 = TMPTAB.ACCADDRESS2, HH.ACCADDRESS3 = TMPTAB.ACCADDRESS3, HH.ACCADDRESS4 = TMPTAB.ACCADDRESS4,
                  HH.ACCPOSTCODE = TMPTAB.ACCPOSTCODE, HH.INTERDEPTCUST = TMPTAB.INTERDEPTCUST
              WHEN NOT MATCHED THEN
                  INSERT(HH.CLARECNO, HH.CLAACCCSTSUP, HH.CLAACCCODE, HH.CLAACTIVE, HH.CLACONTACTNAME, HH.ACCNAME, HH.CASHCUSTOMER, HH.DEFDLTRECNO, HH.ACCADDRESS1, 
	                       HH.ACCADDRESS2, HH.ACCADDRESS3,	HH.ACCADDRESS4,	HH.ACCPOSTCODE, HH.INTERDEPTCUST)
                  VALUES(TMPTAB.CLARECNO, TMPTAB.CLAACCCSTSUP, TMPTAB.CLAACCCODE, TMPTAB.CLAACTIVE, TMPTAB.CLACONTACTNAME,TMPTAB.ACCNAME, TMPTAB.CASHCUSTOMER, TMPTAB.DEFDLTRECNO,
                         TMPTAB.ACCADDRESS1, TMPTAB.ACCADDRESS2, TMPTAB.ACCADDRESS3, TMPTAB.ACCADDRESS4, TMPTAB.ACCPOSTCODE, TMPTAB.INTERDEPTCUST);
              END;
            END IF;
                  
              -- THIS SHOULD NEVER HAPPEN AS A VATRATES IS NEVER DELETED BUT WE'LL STICK IT IN 
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM HH_ACCCLASS WHERE CLARECNO = LASTUSED_REC.UNIQUERECNO
              --AND   *-*-*  = LASTUSED_REC.UNIQUERECNO2              
              ;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_HH);
                      
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_ACCCLASS ;
  
  
  /* THIS PROCEDURE TAKES ACCTOSALOFF RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_ACCTOSALOFF */
PROCEDURE PROCESS_ACCTOSALOFF AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_ACCTOSALOFF, C_HH);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO HH_ACCTOSALOFF HH  
              USING 
              (  select  ACSCLARECNO, ACSSALOFFNO, ACSACCCODE,
                        (Select ContName from DocDistContacts where ContRecNo = (Select Max(D2.ContRecNo) from DocDistContacts D2 where D2.ContClaRecNo = AcsClaRecNo)) as ContName,
                        (Select ContEmailAddress from DocDistContacts where ContRecNo = (Select Max(D3.ContRecNo) from DocDistContacts D3 where D3.ContClaRecNo = AcsClaRecNo)) as ContEmailAddress,
                        (Select ContPhone from DocDistContacts where ContRecNo = (Select Max(D3.ContRecNo) from DocDistContacts D3 where D3.ContClaRecNo = AcsClaRecNo)) as ContPhoneNumber,
                        NVL((Select  NVL2(ContEmailAddress,1,0) from DocDistContacts where ContRecNo = (Select Max(D3.ContRecNo) from DocDistContacts D3 where D3.ContClaRecNo = AcsClaRecNo)),0) as ContSendEmail
                 from acctosaloff
                 WHERE ACSCLARECNO = LASTUSED_REC.UNIQUERECNO
                 AND ACSSALOFFNO = LASTUSED_REC.UNIQUERECNO2
                 ) 
                  TMPTAB
              ON (TMPTAB.ACSCLARECNO = HH.ACSCLARECNO AND TMPTAB.ACSSALOFFNO = HH.ACSSALOFFNO )
              WHEN MATCHED THEN 
                  UPDATE SET  HH.ACSACCCODE = TMPTAB.ACSACCCODE, 
                  HH.CONTNAME = TMPTAB.CONTNAME, HH.CONTEMAILADDRESS = TMPTAB.CONTEMAILADDRESS, HH.CONTPHONENUMBER = TMPTAB.CONTPHONENUMBER,  HH.CONTSENDEMAIL = TMPTAB.CONTSENDEMAIL
              WHEN NOT MATCHED THEN
                  INSERT( HH.ACSCLARECNO,HH.ACSSALOFFNO,  HH.ACSACCCODE,  HH.CONTNAME,  HH.CONTEMAILADDRESS, HH.CONTPHONENUMBER,  HH.CONTSENDEMAIL )
                  VALUES( TMPTAB.ACSCLARECNO,  TMPTAB.ACSSALOFFNO,  TMPTAB.ACSACCCODE, TMPTAB.CONTNAME, TMPTAB.CONTEMAILADDRESS, TMPTAB.CONTPHONENUMBER, TMPTAB.CONTSENDEMAIL);
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM HH_ACCTOSALOFF WHERE ACSCLARECNO = LASTUSED_REC.UNIQUERECNO
              AND ACSSALOFFNO = LASTUSED_REC.UNIQUERECNO2              
              ;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_HH);
                      
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_ACCTOSALOFF ;
   

  
  
  /* THIS PROCEDURE TAKES ACCCAT RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_ACCCAT */
  PROCEDURE PROCESS_ACCCAT AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_ACCCAT, C_HH);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              /* TV 17May16 changed merge to only process certain claclass record types */
              MERGE INTO HH_ACCCAT HH  
              USING 
              ( SELECT CATCLARECNO, CLACLASS FROM ACCCAT
                  WHERE CATCLARECNO = LASTUSED_REC.UNIQUERECNO
                  AND CLACLASS IN (5,6,8,11)
                  ) 
                  TMPTAB
              ON (TMPTAB.CATCLARECNO = HH.CATCLARECNO and TMPTAB.CLACLASS = HH.CLACLASS)
              WHEN NOT MATCHED THEN
                  INSERT(HH.CATCLARECNO, HH.CLACLASS)
                  VALUES(TMPTAB.CATCLARECNO,  TMPTAB.CLACLASS);
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM HH_ACCCAT WHERE CATCLARECNO = LASTUSED_REC.UNIQUERECNO
              AND   CLACLASS  = LASTUSED_REC.UNIQUERECNO2              
              ;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_HH);
            commit;          
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_ACCCAT ;
  
  /* THIS PROCEDURE TAKES DLVTYPE RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_DLVTYPE */
  PROCEDURE PROCESS_DLVTYPE AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_DLVTYPE, C_HH);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO HH_DLVTYPE HH  
              USING 
              ( SELECT DLTRECNO, DELIVERYCONDITION,  DELIVERYCONDITIONDESC FROM DLVTYPE
                  WHERE DLTRECNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.DLTRECNO = HH.DLTRECNO )
              WHEN MATCHED THEN 
                  UPDATE SET HH.DELIVERYCONDITION = TMPTAB.DELIVERYCONDITION,  HH.DELIVERYCONDITIONDESC = TMPTAB.DELIVERYCONDITIONDESC
              WHEN NOT MATCHED THEN
                  INSERT(HH.DLTRECNO, HH.DELIVERYCONDITION,  HH.DELIVERYCONDITIONDESC)
                  VALUES(TMPTAB.DLTRECNO, TMPTAB.DELIVERYCONDITION,  TMPTAB.DELIVERYCONDITIONDESC);
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM HH_DLVTYPE WHERE DLTRECNO = LASTUSED_REC.UNIQUERECNO            
              ;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_HH);
                      
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_DLVTYPE ;
  
  /* THIS PROCEDURE TAKES ALLOCATE RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_ALLOCATE */
  PROCEDURE PROCESS_ALLOCATE AS  
     LOTITE_TABLETYPE INTEGER; 
     INSERTGUID INTEGER := 0;
     TMPALLOC INTEGER;
  BEGIN
    
    
    OPEN LASTUSED_CUR(C_ALLOCATE, C_HH );
    
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
          INSERTGUID := 0; 
          IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
          OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
          BEGIN
             --Make sure that the HH_GUID table is populated with a GUID for the lotite.  If it is not, then write a new record
             --to the table which will automatically allocate a new one
            LOTITE_TABLETYPE := C_LOTITE;
            BEGIN
                SELECT ALLOCATE.ALLOCNO INTO TMPALLOC
                from HH_GUID, ALLOCATE 
                where HH_GUID.FTTABLEID = LOTITE_TABLETYPE
                and HH_GUID.FTTABLEKEY = NVL(ALLOCATE.ALLOCLITITENO, -1)
                AND LASTUSED_REC.UNIQUERECNO = ALLOCATE.ALLOCNO;
             EXCEPTION
                WHEN NO_DATA_FOUND THEN
                   NULL;
                   INSERTGUID := 1;
                WHEN OTHERS THEN
                   --RAISE_APPLICATION_ERROR(-20001, 'FT_PK_HH - Process_Allocate');
                   FT_PK_ERRORS.LOG_AND_CONTINUE;
             END;
             
             /* Changed TV 17May16 so that records where there is no GUID are just left and 
                processed later once the PO creation has added the GUID 		 
                Put back 18May16 to generate the GUID for FT POs.  There is now a trigger on the HH_GUID table to cause 
                the allocate to be re-updated when the HH PO is created */
             IF INSERTGUID = 1 THEN
             BEGIN
                INSERT INTO HH_GUID (FTTABLEKEY, FTTABLEID)
                VALUES((SELECT NVL(ALLOCATE.ALLOCLITITENO, -1) FROM ALLOCATE WHERE ALLOCATE.ALLOCNO = LASTUSED_REC.UNIQUERECNO), LOTITE_TABLETYPE);
                COMMIT;
                INSERTGUID := 0; /* insertion succeeded */
             EXCEPTION
                WHEN OTHERS THEN
                   RAISE_APPLICATION_ERROR(-20001, 'FT_PK_HH - Process_Allocate - GUID insertion');
             END;
             END IF;
      
             
			 IF INSERTGUID = 0 THEN
       BEGIN
                MERGE INTO HH_ALLOCATE HH  
                USING 
                (   SELECT
                    ALLOCATE.ALLOCLITITENO, ALLOCATE.ALLOCNO, ALLOCATE.ALLOCPRDNO, ALLOCATE.ALLOCSENCODE, ALLOCATE.ALLOCPONO, ALLOCATE.ALLOCLITID, ALLOCATE.ALLOCSTCLOC, ALLOCATE.ALLOCSALOFFNO, ALLOCATE.ALLOCDPTRECNO,
                    NVL(ALLOCATE.ALLOCEXP,0) ALLOCEXPBOX, 
                    NVL(ALLOCATE.ALLOCQTY,0) ALLOCQTYBOX, 
                    NVL(ALLOCATE.ALLOCALLOC,0) ALLOCALLOCBOX,
                    SUM(NVL((CASE WHEN  SPLITALLOCATE.ALLOCBY = 2 THEN NVL(SPLITALLOCATE.ALLOCALLOC,0) ELSE 0 END ),0))  ALLOCALLOCWEIGHT,
                    SUM(NVL((CASE WHEN  SPLITALLOCATE.ALLOCBY = 2 THEN NVL(SPLITALLOCATE.ALLOCQTY,0) ELSE 0 END ),0))  ALLOCQTYWEIGHT,
                    SUM(NVL((CASE WHEN  SPLITALLOCATE.ALLOCBY = 3 THEN NVL(SPLITALLOCATE.ALLOCALLOC,0) ELSE 0 END ),0))  ALLOCALLOCEACH,
                    SUM(NVL((CASE WHEN  SPLITALLOCATE.ALLOCBY = 3 THEN NVL(SPLITALLOCATE.ALLOCQTY,0) ELSE 0 END ),0))  ALLOCQTYEACH,
                    SUM(NVL((CASE WHEN  SPLITALLOCATE.ALLOCBY = 4 THEN NVL(SPLITALLOCATE.ALLOCALLOC,0) ELSE 0 END ),0))   ALLOCALLOCINNER,
                    SUM(NVL((CASE WHEN  SPLITALLOCATE.ALLOCBY = 4 THEN NVL(SPLITALLOCATE.ALLOCQTY,0) ELSE 0 END ),0))  ALLOCQTYINNER,
                     (select prdrec.InnerQty from prdrec where prdrec.PrcPrdNo = ALLOCATE.ALLOCPRDNO) as INNERQTY,
                    (select prdrec.PrcBoxQty from prdrec where prdrec.PrcPrdNo = ALLOCATE.ALLOCPRDNO) as PRCBOXQTY,
                    (select prdrec.PrcWeight from prdrec where prdrec.PrcPrdNo = ALLOCATE.ALLOCPRDNO) as PRCWEIGHT,
                    (select NVL(Lotite.LitQtyRcv,0) from Lotite where Lotite.LitIteNo = ALLOCATE.ALLOCLITITENO) as ORGRCVDQTY,
                    (SELECT HH_GUID.GUID from HH_GUID where HH_GUID.FTTABLEID = LOTITE_TABLETYPE and HH_GUID.FTTABLEKEY = NVL(ALLOCATE.ALLOCLITITENO, -1)) AS ALLOCLITITEGUID,
                    (select Lotite.LITID2 from Lotite where Lotite.LitIteNo = ALLOCATE.ALLOCLITITENO) as LotIdentity2,
                    (select NVL(Lotite.LITUNICOST,0.0) from Lotite where Lotite.LitIteNo = ALLOCATE.ALLOCLITITENO) as BuyPrce,
                    (select NVL(Lotite.MGPRICE,0) from Lotite where Lotite.LitIteNo = ALLOCATE.ALLOCLITITENO) as ListedBuyPrice,
                    (select NVL(Lotite.LITGUIDEPRICE,0) from Lotite where Lotite.LitIteNo = ALLOCATE.ALLOCLITITENO) as SellPrice,
                    (select Lotite.LITRCVDATE from Lotite where Lotite.LitIteNo = ALLOCATE.ALLOCLITITENO) as LitRcvDate
                    FROM ALLOCATE , ALLOCATESPLITS LINKALLOCATE, ALLOCATE SPLITALLOCATE, LOTITE
                    WHERE ALLOCATE.ALLOCNO = LINKALLOCATE.BOXALLOCNO(+)
                    AND  LINKALLOCATE.SPLITALLOCNO = SPLITALLOCATE.ALLOCNO(+)
                    AND LOTITE.LITITENO = allocate.alloclititeno
                    AND ALLOCATE.ALLOCNO = LASTUSED_REC.UNIQUERECNO
                    GROUP BY
                    ALLOCATE.ALLOCLITITENO, ALLOCATE.ALLOCNO, ALLOCATE.ALLOCPRDNO, ALLOCATE.ALLOCSENCODE, ALLOCATE.ALLOCPONO, ALLOCATE.ALLOCLITID, ALLOCATE.ALLOCSTCLOC,
                    ALLOCATE.ALLOCSALOFFNO, ALLOCATE.ALLOCDPTRECNO, ALLOCATE.ALLOCEXP, ALLOCATE.ALLOCQTY, ALLOCATE.ALLOCALLOC,
                    LOTITE.LITID2, LOTITE.LITUNICOST, LOTITE.MGPRICE, LOTITE.LITGUIDEPRICE 

                    /* TV 18May16 Before Lotite added
                    SELECT
                    ALLOCATE.ALLOCLITITENO, ALLOCATE.ALLOCNO, ALLOCATE.ALLOCPRDNO, ALLOCATE.ALLOCSENCODE, ALLOCATE.ALLOCPONO, ALLOCATE.ALLOCLITID, ALLOCATE.ALLOCSTCLOC, ALLOCATE.ALLOCSALOFFNO, ALLOCATE.ALLOCDPTRECNO,
                    NVL(ALLOCATE.ALLOCEXP,0) ALLOCEXPBOX, 
                    NVL(ALLOCATE.ALLOCQTY,0) ALLOCQTYBOX, 
                    NVL(ALLOCATE.ALLOCALLOC,0) ALLOCALLOCBOX,
                    SUM(NVL((CASE WHEN  SPLITALLOCATE.ALLOCBY = 2 THEN NVL(SPLITALLOCATE.ALLOCALLOC,0) ELSE 0 END ),0))  ALLOCALLOCWEIGHT,
                    SUM(NVL((CASE WHEN  SPLITALLOCATE.ALLOCBY = 2 THEN NVL(SPLITALLOCATE.ALLOCQTY,0) ELSE 0 END ),0))  ALLOCQTYWEIGHT,
                    SUM(NVL((CASE WHEN  SPLITALLOCATE.ALLOCBY = 3 THEN NVL(SPLITALLOCATE.ALLOCALLOC,0) ELSE 0 END ),0))  ALLOCALLOCEACH,
                    SUM(NVL((CASE WHEN  SPLITALLOCATE.ALLOCBY = 3 THEN NVL(SPLITALLOCATE.ALLOCQTY,0) ELSE 0 END ),0))  ALLOCQTYEACH,
                    SUM(NVL((CASE WHEN  SPLITALLOCATE.ALLOCBY = 4 THEN NVL(SPLITALLOCATE.ALLOCALLOC,0) ELSE 0 END ),0))   ALLOCALLOCINNER,
                    SUM(NVL((CASE WHEN  SPLITALLOCATE.ALLOCBY = 4 THEN NVL(SPLITALLOCATE.ALLOCQTY,0) ELSE 0 END ),0))  ALLOCQTYINNER,
                     (select prdrec.InnerQty from prdrec where prdrec.PrcPrdNo = ALLOCATE.ALLOCPRDNO) as INNERQTY,
                    (select prdrec.PrcBoxQty from prdrec where prdrec.PrcPrdNo = ALLOCATE.ALLOCPRDNO) as PRCBOXQTY,
                    (select prdrec.PrcWeight from prdrec where prdrec.PrcPrdNo = ALLOCATE.ALLOCPRDNO) as PRCWEIGHT,
                    (select NVL(Lotite.LitQtyRcv,0) from Lotite where Lotite.LitIteNo = ALLOCATE.ALLOCLITITENO) as ORGRCVDQTY,
                    (SELECT HH_GUID.GUID from HH_GUID where HH_GUID.FTTABLEID = LOTITE_TABLETYPE and HH_GUID.FTTABLEKEY = NVL(ALLOCATE.ALLOCLITITENO, -1)) AS ALLOCLITITEGUID
                    FROM ALLOCATE , ALLOCATESPLITS LINKALLOCATE, ALLOCATE SPLITALLOCATE
                    WHERE ALLOCATE.ALLOCNO = LINKALLOCATE.BOXALLOCNO(+)
                    AND  LINKALLOCATE.SPLITALLOCNO = SPLITALLOCATE.ALLOCNO(+)
                    AND ALLOCATE.ALLOCNO = LASTUSED_REC.UNIQUERECNO
                    GROUP BY
                    ALLOCATE.ALLOCLITITENO, ALLOCATE.ALLOCNO, ALLOCATE.ALLOCPRDNO, ALLOCATE.ALLOCSENCODE, ALLOCATE.ALLOCPONO, ALLOCATE.ALLOCLITID, ALLOCATE.ALLOCSTCLOC,
                    ALLOCATE.ALLOCSALOFFNO, ALLOCATE.ALLOCDPTRECNO, ALLOCATE.ALLOCEXP, ALLOCATE.ALLOCQTY, ALLOCATE.ALLOCALLOC */
                ) 
                    TMPTAB
                ON (TMPTAB.ALLOCLITITEGUID = HH.ALLOCLITITEGUID )
                WHEN MATCHED THEN 
                   UPDATE SET HH.ALLOCPRDNO = TMPTAB.ALLOCPRDNO, HH. ALLOCSENCODE = TMPTAB.ALLOCSENCODE, HH.ALLOCPONO = TMPTAB.ALLOCPONO, HH.ALLOCLITID = TMPTAB.ALLOCLITID, 
                              HH.ALLOCSTCLOC = TMPTAB.ALLOCSTCLOC, HH.ALLOCEXPBOX = TMPTAB.ALLOCEXPBOX, HH.ALLOCALLOCBOX = TMPTAB.ALLOCALLOCBOX, 
                              HH.ALLOCQTYBOX = TMPTAB.ALLOCQTYBOX, HH.ALLOCSALOFFNO = TMPTAB.ALLOCSALOFFNO, HH.ALLOCDPTRECNO = TMPTAB.ALLOCDPTRECNO, HH.ALLOCLITITENO = TMPTAB.  ALLOCLITITENO,
                              HH.ALLOCNO = TMPTAB.ALLOCNO, HH.INNERQTY = TMPTAB.INNERQTY, HH.ALLOCQTYINNER = TMPTAB.ALLOCQTYINNER, HH.ALLOCALLOCINNER = TMPTAB.ALLOCALLOCINNER, HH.PRCBOXQTY = TMPTAB.PRCBOXQTY,
                              HH.ALLOCQTYEACH = TMPTAB.ALLOCQTYEACH, HH.ALLOCALLOCEACH = TMPTAB.ALLOCALLOCEACH, HH.PRCWEIGHT = TMPTAB.PRCWEIGHT, HH.ALLOCQTYWEIGHT = TMPTAB.ALLOCQTYWEIGHT, 
                              HH.ALLOCALLOCWEIGHT = TMPTAB.ALLOCALLOCWEIGHT, HH.ORGRCVDQTY = TMPTAB.ORGRCVDQTY, 
                              HH.LotIdentity2 = TMPTAB.LotIdentity2, HH.BuyPrce = TMPTAB.BuyPrce, HH.ListedBuyPrice = TMPTAB.ListedBuyPrice, HH.SellPrice = TMPTAB.SellPrice, HH.LitRcvDate = TMPTAB.LitRcvDate 
                WHEN NOT MATCHED THEN
                    INSERT(HH.ALLOCLITITEGUID, HH.ALLOCNO, HH.ALLOCPRDNO, HH.ALLOCSENCODE, HH.ALLOCPONO, HH.ALLOCLITID, HH.ALLOCSTCLOC, HH.ALLOCQTYBOX, HH.ALLOCALLOCBOX, HH.ALLOCEXPBOX,       HH.ALLOCSALOFFNO, 
                           HH.ALLOCDPTRECNO, HH.ALLOCLITITENO,  HH.INNERQTY, HH.ALLOCQTYINNER, HH.ALLOCALLOCINNER, HH.PRCBOXQTY, HH.ALLOCQTYEACH, HH.ALLOCALLOCEACH, HH.PRCWEIGHT, HH.ALLOCQTYWEIGHT, HH.ALLOCALLOCWEIGHT, HH.ORGRCVDQTY,
                           HH.LotIdentity2, HH.BuyPrce, HH.ListedBuyPrice, HH.SellPrice, HH.LitRcvDate)
                    VALUES(TMPTAB.ALLOCLITITEGUID, TMPTAB.ALLOCNO, TMPTAB.ALLOCPRDNO,  TMPTAB.ALLOCSENCODE, TMPTAB.ALLOCPONO, TMPTAB.ALLOCLITID, TMPTAB.ALLOCSTCLOC, TMPTAB.ALLOCQTYBOX, TMPTAB.ALLOCALLOCBOX, TMPTAB.ALLOCEXPBOX, TMPTAB.ALLOCSALOFFNO,
                    TMPTAB.ALLOCDPTRECNO, TMPTAB.ALLOCLITITENO,  TMPTAB.INNERQTY, TMPTAB.ALLOCQTYINNER, TMPTAB.ALLOCALLOCINNER, TMPTAB.PRCBOXQTY, TMPTAB.ALLOCQTYEACH, TMPTAB.ALLOCALLOCEACH, TMPTAB.PRCWEIGHT, TMPTAB.ALLOCQTYWEIGHT,
                    TMPTAB.ALLOCALLOCWEIGHT, TMPTAB.ORGRCVDQTY,
                    TMPTAB.LotIdentity2, TMPTAB.BuyPrce, TMPTAB.ListedBuyPrice, TMPTAB.SellPrice, TMPTAB.LitRcvDate);
                END;
			END IF;
      END;
          END IF;
                
          -- ALLOCATES DO GET DELETED  
          IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
          BEGIN
             DELETE FROM HH_ALLOCATE WHERE ALLOCNO = LASTUSED_REC.UNIQUERECNO;      
          END;
          END IF;
          
		  IF INSERTGUID = 0 THEN
          BEGIN		
             /* Only delete if the GUID existed or was a delete */		  
             DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_HH);
        END;
          END IF;
		  
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;              
      END IF; 
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_ALLOCATE ;
  
  
  
     /* THIS PROCEDURE TAKES GUID RECORDS FROM HH_TABLE_LASTUSED AND UPDATES TABLES THAT USE THEM LIKE HH_ALLOCATE */
  PROCEDURE PROCESS_HH_GUID AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_HH_GUID, C_HH);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
            BEGIN
               IF LASTUSED_REC.UNIQUERECNO = C_LOTITE THEN
               BEGIN
                  /* Update Allocate with a changed Lotite.LitRecNo */
                  UPDATE HH_ALLOCATE
                  SET HH_ALLOCATE.ALLOCLITITEGUID = (SELECT GUID from HH_GUID where FTTABLEID = LASTUSED_REC.UNIQUERECNO and FTTABLEKEY = LASTUSED_REC.UNIQUERECNO2)
                  WHERE HH_ALLOCATE.ALLOCLITITENO = LASTUSED_REC.UNIQUERECNO2;
               END;
               END IF;
            END;
            END IF;
                  
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_HH);
                      
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_HH_GUID ;
  
  
   /* THIS PROCEDURE TAKES LOTITE RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_LOTITE */
  PROCEDURE PROCESS_LOTITE AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_LOTITE , C_HH);
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO HH_LOTITE HH  
              USING 
              ( SELECT  LITITENO, LITPORREC, LITORGEXP, LITQTYRCV, LITEXPDATE, LITRCVIND, LITRCVDATE, LITPRDNO, LITSTCLOC, 
                        LITUNICOST, LITID, LITBUYER, LITRCVCOMPLETE, LITRTSQTY, LITPURBYTYP, LITGUIDEPRICE, LITID2, MGPRICE
                  FROM LOTITE
                  WHERE LITITENO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.LITITENO = HH.LITITENO )
              WHEN MATCHED THEN 
                  UPDATE SET HH.LITPORREC = TMPTAB.LITPORREC,HH.LITORGEXP = TMPTAB.LITORGEXP, HH.LITQTYRCV = TMPTAB.LITQTYRCV, HH.LITEXPDATE = TMPTAB.LITEXPDATE, 
                             HH.LITRCVIND = TMPTAB.LITRCVDATE, HH.LITRCVDATE = TMPTAB.LITRCVDATE, HH.LITPRDNO = TMPTAB.LITPRDNO, HH.LITSTCLOC = TMPTAB.LITSTCLOC, 
                             HH.LITUNITCOST = TMPTAB.LITUNICOST, HH.LITID = TMPTAB.LITID, HH.LITBUYER = TMPTAB.LITBUYER, HH.LITRCVCOMPLETE = TMPTAB.LITRCVCOMPLETE, 
                             HH.LITRTSQTY = TMPTAB.LITRTSQTY, HH.LITPURBYTYP = TMPTAB.LITPURBYTYP, HH.LITGUIDEPRICE = TMPTAB.LITGUIDEPRICE, HH.LITID2 = TMPTAB.LITID2, HH.MGPRICE = TMPTAB.MGPRICE
              WHEN NOT MATCHED THEN
                  INSERT(HH. LITITENO, HH.LITPORREC,HH.LITORGEXP, HH.LITQTYRCV, HH.LITEXPDATE, HH.LITRCVIND, HH.LITRCVDATE, HH.LITPRDNO, HH.LITSTCLOC, 
                        HH.LITUNITCOST, HH.LITID,HH.LITBUYER, HH.LITRCVCOMPLETE, HH.LITRTSQTY, HH.LITPURBYTYP, HH.LITGUIDEPRICE, HH.LITID2, HH.MGPRICE)
                  VALUES(TMPTAB.LITITENO, TMPTAB.LITPORREC, TMPTAB.LITORGEXP, TMPTAB.LITQTYRCV, TMPTAB.LITEXPDATE, TMPTAB.LITRCVIND, TMPTAB.LITRCVDATE, TMPTAB.LITPRDNO, TMPTAB.LITSTCLOC, 
                        TMPTAB.LITUNICOST, TMPTAB.LITID, TMPTAB.LITBUYER, TMPTAB.LITRCVCOMPLETE, TMPTAB.LITRTSQTY, TMPTAB.LITPURBYTYP, TMPTAB.LITGUIDEPRICE, TMPTAB.LITID2, TMPTAB.MGPRICE);
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM HH_LOTITE WHERE LITITENO = LASTUSED_REC.UNIQUERECNO            
              ;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE, C_HH);
                      
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_LOTITE ;
  
     /* THIS PROCEDURE TAKES LOTITE RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_LOTITE */
  PROCEDURE PROCESS_LOOKUPS AS  
  BEGIN
    OPEN LOOKUPS_CUR;
    LOOP
      FETCH LOOKUPS_CUR INTO LOOKUPS_REC;
      
      EXIT WHEN LOOKUPS_CUR%NOTFOUND;
    
      IF LOOKUPS_CUR%FOUND THEN              
      BEGIN 
         /* always going to be a create or edit for lookups */   
        
         MERGE INTO HH_LOOKUPS HH  
         USING 
            ( SELECT  LKUPTABLE, LKUPFIELDNAME, LKUPNO, LKUPDESC 
              FROM LOOKUPS
              WHERE LKUPTABLE = LOOKUPS_REC.LKUPTABLE
              AND   LKUPFIELDNAME = LOOKUPS_REC.LKUPFIELDNAME
              AND   LKUPNO = LOOKUPS_REC.LKUPNO
               ) 
               TMPTAB
            ON (TMPTAB.LKUPTABLE = HH.LKUPTABLE AND TMPTAB.LKUPFIELDNAME = HH.LKUPFIELDNAME AND TMPTAB.LKUPNO = HH.LKUPNO )
            WHEN MATCHED THEN 
                UPDATE SET HH.LKUPDESC = TMPTAB.LKUPDESC 
            WHEN NOT MATCHED THEN
                INSERT(HH.LKUPTABLE, HH.LKUPFIELDNAME, HH.LKUPNO, HH.LKUPDESC)
                VALUES(TMPTAB.LKUPTABLE, TMPTAB.LKUPFIELDNAME, TMPTAB.LKUPNO, TMPTAB.LKUPDESC);
    
             DELETE FROM HH_TABLE_LASTUSED 
              WHERE TABLEFLAG     = C_LOOKUPS;
                      
        EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
         END;
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LOOKUPS_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LOOKUPS_CUR%ISOPEN THEN
        CLOSE LOOKUPS_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_LOOKUPS ;
  
  /* THIS PROCEDURE TAKES TKTBK RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_TKTBK 
 
  PROCEDURE PROCESS_TKTBK AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_TKTBK );
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO HH_TKTBK HH  
              USING 
              ( SELECT  TBKRECNO, TBKDESC, TBKSTARTNO, TBKENDNO, TBKSMNNO, TBKSALOFFNO, TBKCREATEDATELI, TBKCOMPLETE, TBKTYPE, TBKUSEDFOR, AVAILTOSEND
                  FROM TKTBK
                  WHERE TBKRECNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.TBKRECNO = HH.TBKRECNO )
              WHEN MATCHED THEN 
                  UPDATE SET HH.TBKDESC = TMPTAB.TBKDESC, HH.TBKSTARTNO = TMPTAB.TBKSTARTNO, HH.TBKENDNO = TMPTAB.TBKENDNO, HH.TBKSMNNO = TMPTAB.TBKSMNNO, HH.TBKSALOFFNO = TMPTAB.TBKSALOFFNO, 
                             HH.TBKCREATEDATELI = TMPTAB.TBKCREATEDATELI, HH.TBKCOMPLETE = TMPTAB.TBKCOMPLETE, HH.TBKTYPE = TMPTAB.TBKTYPE, HH.TBKUSEDFOR = TMPTAB.TBKUSEDFOR, HH.AVAILTOSEND = TMPTAB.AVAILTOSEND
              WHEN NOT MATCHED THEN
                  INSERT(HH.TBKRECNO, HH.TBKDESC, HH.TBKSTARTNO, HH.TBKENDNO, HH.TBKSMNNO, HH.TBKSALOFFNO, HH.TBKCREATEDATELI, HH.TBKCOMPLETE, HH.TBKTYPE, HH.TBKUSEDFOR, HH.AVAILTOSEND)
                  VALUES(TMPTAB.TBKRECNO, TMPTAB.TBKDESC, TMPTAB.TBKSTARTNO, TMPTAB.TBKENDNO, TMPTAB.TBKSMNNO, TMPTAB.TBKSALOFFNO, TMPTAB.TBKCREATEDATELI, TMPTAB.TBKCOMPLETE, TMPTAB.TBKTYPE, TMPTAB.TBKUSEDFOR,TMPTAB.AVAILTOSEND);
              END;
            END IF;
                  
            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM HH_TKTBK WHERE TBKRECNO = LASTUSED_REC.UNIQUERECNO            
              ;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE);
                      
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_TKTBK ; */
  
  /* THIS PROCEDURE TAKES TKTNT RECORDS FROM HH_TABLE_LASTUSED AND WRITES THEM TO HH_TKTNT */
  /* No longer required
  PROCEDURE PROCESS_TKTNT AS  
  BEGIN
    
    OPEN LASTUSED_CUR(C_TKTNT );
    LOOP
      FETCH LASTUSED_CUR INTO LASTUSED_REC;
      
      EXIT WHEN LASTUSED_CUR%NOTFOUND;
    
      IF LASTUSED_CUR%FOUND THEN              
      BEGIN 
            IF LASTUSED_REC.OPERATIONTYPE = C_CREATE 
            OR LASTUSED_REC.OPERATIONTYPE = C_UPDATE THEN
              BEGIN
              MERGE INTO HH_TKTNT HH  
              USING 
              ( SELECT  TNTRECNO, TNTNO, TNTTBKRECNO, TNTDLVORDNO
                  FROM TKTNT
                  WHERE TNTRECNO = LASTUSED_REC.UNIQUERECNO
                  ) 
                  TMPTAB
              ON (TMPTAB.TNTRECNO = HH.TNTRECNO )
              WHEN MATCHED THEN 
                  UPDATE SET HH.TNTNO = TMPTAB.TNTNO, HH.TNTTBKRECNO = TMPTAB.TNTTBKRECNO, HH.TNTDLVORDNO = TMPTAB.TNTDLVORDNO
              WHEN NOT MATCHED THEN
                  INSERT(HH.TNTRECNO, HH.TNTNO, HH.TNTTBKRECNO, HH.TNTDLVORDNO)
                  VALUES(TMPTAB.TNTRECNO, TMPTAB.TNTNO, TMPTAB.TNTTBKRECNO, TMPTAB.TNTDLVORDNO);
              END;
            END IF;

            IF LASTUSED_REC.OPERATIONTYPE = C_DELETE  THEN
            BEGIN
              DELETE FROM HH_TKTNT WHERE TNTRECNO = LASTUSED_REC.UNIQUERECNO            
              ;              
            END;
            END IF;
            
            DELETE_HH_TABLE_LASTUSED(LASTUSED_REC.UNIQUERECNO, LASTUSED_REC.UNIQUERECNO2, LASTUSED_REC.TABLEFLAG, LASTUSED_REC.OPERATIONTYPE);
                      
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE LASTUSED_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF LASTUSED_CUR%ISOPEN THEN
        CLOSE LASTUSED_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END PROCESS_TKTNT ; */
  
  /* THIS PROCEDURE CALLS ALL THE REST OF THE REFLAG PROCEDURES  TO RESEND EVERTHING TO THE HH_TABLE_LASTUSED TABLE */
  PROCEDURE REFLAG_ALL IS
  BEGIN
    REFLAG_ALL_DLVTYPE();
    REFLAG_ALL_ACCCLASS();
    REFLAG_ALL_ACCCAT();
    REFLAG_ALL_SALOFFNO();
    REFLAG_ALL_ACCTOSALOFF();
    REFLAG_ALL_DEPARTMENTS();
    REFLAG_ALL_DPTTOSALOFFNO();
    REFLAG_ALL_SMN();
    REFLAG_ALL_DEPARTMENTSTOSMN();
    REFLAG_ALL_LOGONS();
    REFLAG_ALL_LOGTOSALOFF();
    REFLAG_ALL_SMNTOLOGON();
    REFLAG_ALL_SOFTOSTCLOC();
    REFLAG_ALL_PRDALLDESCS();     
    REFLAG_ALL_PRDRECS();
    -- REFLAG_ALL_PRDRECTOSO();   -- SHOULD NOT NEED TO DO THIS IF REFLAG_ALL_PRDRECS IS CALLED AS IT ALREADY DOES ALL THE PRDRECTOSO VIA REFLAG_PRDRECTOSO_FORPRDREC    
    REFLAG_ALL_VATRATES();
    REFLAG_ALL_ALLOCATE();
    REFLAG_ALL_LOOKUPS();
 
    /*REFLAG_ALL_LOTITE();
    REFLAG_ALL_TKTBK();
    REFLAG_ALL_TKTNT();*/
    
  END REFLAG_ALL; 
  
  /* GENERIC PROCEDURE - TAKES A CURSOR AND FLAGS ALL TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED */
  PROCEDURE REFLAG_GENERIC(IN_TABLEFLAG NUMBER, IN_CURSOR SYS_REFCURSOR) AS        
   TYPE DATAITEM IS RECORD (
      UNIQNO1     NUMBER(10),
      UNIQNO2     NUMBER(10));
   DATA_REC DATAITEM;
  
  BEGIN  
   LOOP
      FETCH IN_CURSOR INTO DATA_REC;
      EXIT WHEN IN_CURSOR%NOTFOUND;
      BEGIN 
        FT_PK_HH.INSERT_LASTUSED(DATA_REC.UNIQNO1, DATA_REC.UNIQNO2, IN_TABLEFLAG, C_GENERICREFLAGACTION);                
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;          
    END LOOP;    
    COMMIT;
    CLOSE IN_CURSOR;
  EXCEPTION
    WHEN OTHERS THEN
      IF IN_CURSOR%ISOPEN THEN
        CLOSE IN_CURSOR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
    
  END REFLAG_GENERIC;

  /* THIS PROCEDURE FLAGS ALL EXISTING PRDREC RECORDS TO BE RE-SENT - IE WRITES TO HH_TABLE_LASTUSED */  
  PROCEDURE REFLAG_ALL_PRDRECS
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT PRDREC.PRCPRDNO AS UNIQNO1, -1 UNIQNO2 FROM PRDREC;
    REFLAG_GENERIC(C_PRDREC, SYS_CUR);
    
  END REFLAG_ALL_PRDRECS;

  /* THIS PROCEDURE FLAGS ALL EXISTING PRDALLDESCS RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/  
  PROCEDURE REFLAG_ALL_PRDALLDESCS
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT PRDALLDESCS.ALLPREFNO AS UNIQNO1, -1 UNIQNO2 FROM PRDALLDESCS;
    REFLAG_GENERIC(C_PRDALLDESCS, SYS_CUR);
    
  END REFLAG_ALL_PRDALLDESCS;
    
  /* THIS PROCEDURE FLAGS ALL EXISTING PRDALLDESCS RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED
  **NOTE** THERE IS NO NEED TO CALL THIS IF REFLAG_ALL_PRDRECS IS CALLED AS THAT WILL SEND ALL PRDRECTOSO RECORDS ANYWAY
  */  
  PROCEDURE REFLAG_ALL_PRDRECTOSO
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT PRDRECTOSO.SALOFFNO AS UNIQNO1, PRCPRDNO UNIQNO2 FROM PRDRECTOSO;
    REFLAG_GENERIC(C_PRDRECTOSO, SYS_CUR);
    
  END REFLAG_ALL_PRDRECTOSO;
    
  /* THIS PROCEDURE FLAGS ALL EXISTING LOGONS RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/  
  PROCEDURE REFLAG_ALL_LOGONS
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT LOGONS.LOGONNO AS UNIQNO1, -1 UNIQNO2 FROM LOGONS  ;
    REFLAG_GENERIC(C_LOGONS , SYS_CUR);
    
  END REFLAG_ALL_LOGONS;
  
  /* THIS PROCEDURE FLAGS ALL EXISTING LOGTOSALOFF RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_LOGTOSALOFF
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT LOGTOSALOFF.LOGONNO AS UNIQNO1, LOGTOSALOFF.SALOFFNO UNIQNO2 FROM LOGTOSALOFF WHERE  LOGTOSALOFF.SALOFFNO > 0 AND LOGTOSALOFF.SALOFFNO <32000 ;
    REFLAG_GENERIC(C_LOGTOSALOFF , SYS_CUR);
    
  END REFLAG_ALL_LOGTOSALOFF;
  
  /* THIS PROCEDURE FLAGS ALL EXISTING SALOFFNO RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_SALOFFNO
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT SALOFFNO.SALOFFNO AS UNIQNO1, -1 UNIQNO2 FROM SALOFFNO WHERE SALOFFNO.SALOFFNO > 0 AND SALOFFNO.SALOFFNO < 32000  ;
    REFLAG_GENERIC(C_SALOFFNO , SYS_CUR);
    
  END REFLAG_ALL_SALOFFNO;  
   
   /* THIS PROCEDURE FLAGS ALL EXISTING DEPARTMENTS RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_DEPARTMENTS
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT DEPARTMENTS.DPTRECNO AS UNIQNO1, -1 UNIQNO2 FROM DEPARTMENTS ;
    REFLAG_GENERIC(C_DEPARTMENTS , SYS_CUR);
        
  END REFLAG_ALL_DEPARTMENTS;    

  PROCEDURE REFLAG_ALL_DPTTOSALOFFNO
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT Saloffno.Saloffno AS UNIQNO1, DepartmentS.Dptrecno UNIQNO2 
    FROM saloffno, DEPARTMENTS
    WHERE SALOFFNO > 0;
    
    REFLAG_GENERIC(C_DPTTOSALOFFNO , SYS_CUR);
        
  END REFLAG_ALL_DPTTOSALOFFNO;  
 
    /* THIS PROCEDURE FLAGS ALL EXISTING SMN RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_SMN
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT SMN.SMNNO AS UNIQNO1, -1 UNIQNO2 FROM SMN ;
    REFLAG_GENERIC(C_SMN , SYS_CUR);
        
  END REFLAG_ALL_SMN;  
  
  /* THIS PROCEDURE FLAGS ALL EXISTING SMNTOLOGON RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_SMNTOLOGON
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT SMNTOLOGON.SMNNO AS UNIQNO1, SMNTOLOGON.LOGONNO as UNIQNO2 FROM SMNTOLOGON ;
    REFLAG_GENERIC(C_SMNTOLOGON , SYS_CUR);
        
  END REFLAG_ALL_SMNTOLOGON;
 
  /* THIS PROCEDURE FLAGS ALL EXISTING DEPARTMENTSTOSMN RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_DEPARTMENTSTOSMN
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT DEPARTMENTSTOSMN.DPTRECNO as UNIQNO1, DEPARTMENTSTOSMN.SMNNO AS UNIQNO2 FROM DEPARTMENTSTOSMN ;
    REFLAG_GENERIC(C_DEPARTMENTSTOSMN , SYS_CUR);
        
  END REFLAG_ALL_DEPARTMENTSTOSMN;
  
  /* THIS PROCEDURE FLAGS ALL EXISTING SOFTOSTCLOC RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_SOFTOSTCLOC
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT SOFTOSTCLOC.SALOFFNO AS UNIQNO1, SOFTOSTCLOC.STCLOC as UNIQNO2 FROM SOFTOSTCLOC ;
    REFLAG_GENERIC(C_SOFTOSTCLOC , SYS_CUR);
        
  END REFLAG_ALL_SOFTOSTCLOC;
  
  /* THIS PROCEDURE FLAGS ALL EXISTING ALLOCATE RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_ALLOCATE
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT ALLOCATE.ALLOCNO AS UNIQNO1, -1 as UNIQNO2 FROM ALLOCATE ;
    REFLAG_GENERIC(C_ALLOCATE , SYS_CUR);
        
  END REFLAG_ALL_ALLOCATE;
  
  
   /* THIS PROCEDURE FLAGS ALL REQUIRED LOOKUP RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_LOOKUPS
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT -1 AS UNIQNO1, -1 as UNIQNO2 FROM DUAL ;
    REFLAG_GENERIC(C_LOOKUPS , SYS_CUR);
        
  END REFLAG_ALL_LOOKUPS;
  
   /* IF A PRDREC CHANGES THEN ALL THE ASSOC PRDRECTOSO SHOULD BE PROCESSED - THIS PROCEDURE DOES THAT */
  PROCEDURE REFLAG_PRDRECTOSO_FORPRDREC(IN_PRCPRDNO NUMBER, IN_OPERATIONTYPE VARCHAR2)
  AS
    CURSOR PRDRECTOSO_CUR(IN_PRCPRDNO NUMBER)    
    IS
    SELECT DISTINCT SALOFFNO FROM PRDRECTOSO
    WHERE PRCPRDNO = IN_PRCPRDNO;  
    
    PRDRECTOSO_REC       PRDRECTOSO_CUR%ROWTYPE;  

  BEGIN
    
    OPEN PRDRECTOSO_CUR(IN_PRCPRDNO);
    LOOP
      FETCH PRDRECTOSO_CUR INTO PRDRECTOSO_REC;      
      EXIT WHEN PRDRECTOSO_CUR%NOTFOUND;
    
      IF PRDRECTOSO_CUR%FOUND THEN              
      BEGIN 
        INSERT_LASTUSED(PRDRECTOSO_REC.SALOFFNO, IN_PRCPRDNO, C_PRDRECTOSO, IN_OPERATIONTYPE);
      
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE PRDRECTOSO_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF PRDRECTOSO_CUR%ISOPEN THEN
        CLOSE PRDRECTOSO_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
  
  END REFLAG_PRDRECTOSO_FORPRDREC;
  
  /* THIS PROCEDURE FLAGS ALL EXISTING VATRATES RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_VATRATES
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT VATRATES.VATRECNO AS UNIQNO1, -1 UNIQNO2 FROM VATRATES ;
    REFLAG_GENERIC(C_VATRATES , SYS_CUR);
        
  END REFLAG_ALL_VATRATES;
  
  /* THIS PROCEDURE FLAGS ALL EXISTING VATRATES RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_ACCCLASS
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT ACCCLASS.CLARECNO AS UNIQNO1, -1 UNIQNO2 FROM ACCCLASS ;
    REFLAG_GENERIC(C_ACCCLASS , SYS_CUR);
        
  END REFLAG_ALL_ACCCLASS;
  
    /* THIS PROCEDURE FLAGS ALL EXISTING ACCTOSALOFF RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_ACCTOSALOFF
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT ACSCLARECNO AS UNIQNO1, ACSSALOFFNO UNIQNO2 FROM ACCTOSALOFF WHERE ACCTOSALOFF.ACSSALOFFNO > 0 AND ACCTOSALOFF.ACSSALOFFNO < 32000 ;
    REFLAG_GENERIC(C_ACCTOSALOFF , SYS_CUR);
        
  END REFLAG_ALL_ACCTOSALOFF;
  
  
  
  /* THIS PROCEDURE FLAGS ALL EXISTING VATRATES RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_ACCCAT
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT ACCCAT.CATCLARECNO AS UNIQNO1, ACCCAT.CLACLASS UNIQNO2 FROM ACCCAT ;
    REFLAG_GENERIC(C_ACCCAT , SYS_CUR);
        
  END REFLAG_ALL_ACCCAT;
  
 /* THIS PROCEDURE FLAGS ALL EXISTING VATRATES RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_DLVTYPE
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT DLVTYPE.DLTRECNO AS UNIQNO1, -1 UNIQNO2 FROM DLVTYPE WHERE DLVTYPE.DLTRECNO > 0 ;
    REFLAG_GENERIC(C_DLVTYPE , SYS_CUR);
        
  END REFLAG_ALL_DLVTYPE;
  
  /* THIS PROCEDURE FLAGS ALL EXISTING VATRATES RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_LOTITE
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT LOTITE.LITITENO AS UNIQNO1, -1 UNIQNO2 FROM LOTITE ;
    REFLAG_GENERIC(C_LOTITE , SYS_CUR);
        
  END REFLAG_ALL_LOTITE;
  
  /* THIS PROCEDURE FLAGS ALL EXISTING VATRATES RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_TKTBK
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT TKTBK.TBKRECNO AS UNIQNO1, -1 UNIQNO2 FROM TKTBK ;
    REFLAG_GENERIC(C_TKTBK , SYS_CUR);
        
  END REFLAG_ALL_TKTBK;
  
  /* THIS PROCEDURE FLAGS ALL EXISTING VATRATES RECORDS TO BE RE-SENT  - IE WRITES TO HH_TABLE_LASTUSED*/    
  PROCEDURE REFLAG_ALL_TKTNT
  AS
    SYS_CUR SYS_REFCURSOR;  
  BEGIN
    OPEN SYS_CUR FOR SELECT TKTNT.TNTRECNO AS UNIQNO1, -1 UNIQNO2 FROM TKTNT ;
    REFLAG_GENERIC(C_TKTNT , SYS_CUR);
        
  END REFLAG_ALL_TKTNT;
  
 /* IF A SALOFFNO CHANGES THEN ALL THE ASSOC Departments SHOULD BE PROCESSED - 
    When a DptToSalOffNo table exists in FT this can be got rid of */
  PROCEDURE REFLAG_DPTTOSALOFFNO_S(IN_SALOFFNO NUMBER, IN_OPERATIONTYPE VARCHAR2)
  AS
    CURSOR DPTTOSALOFFNO_CUR    
    IS
    SELECT DISTINCT DPTRECNO FROM DEPARTMENTS; 
    
    DPTTOSALOFFNO_REC       DPTTOSALOFFNO_CUR%ROWTYPE;  

  BEGIN
    
    OPEN DPTTOSALOFFNO_CUR();
    LOOP
      FETCH DPTTOSALOFFNO_CUR INTO DPTTOSALOFFNO_REC;      
      EXIT WHEN DPTTOSALOFFNO_CUR%NOTFOUND;
    
      IF DPTTOSALOFFNO_CUR%FOUND THEN              
      BEGIN 
        INSERT_LASTUSED(IN_SALOFFNO, DPTTOSALOFFNO_REC.DPTRECNO, C_DPTTOSALOFFNO, IN_OPERATIONTYPE);
      
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE DPTTOSALOFFNO_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF DPTTOSALOFFNO_CUR%ISOPEN THEN
        CLOSE DPTTOSALOFFNO_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
  
  END REFLAG_DPTTOSALOFFNO_S;


/* IF A DEPARTMENT CHANGES THEN ALL THE ASSOC SalOffNo SHOULD BE PROCESSED - 
    When a DptToSalOffNo table exists in FT this can be got rid of */
  PROCEDURE REFLAG_DPTTOSALOFFNO_D(IN_DPTRECNO NUMBER, IN_OPERATIONTYPE VARCHAR2)
  AS
    CURSOR SALOFFTODPT_CUR    
    IS
    SELECT DISTINCT SALOFFNO FROM SALOFFNO WHERE SALOFFNO.SALOFFNO > 0 AND SALOFFNO.SALOFFNO < 32000; 
    
    SALOFFTODPT_REC       SALOFFTODPT_CUR%ROWTYPE;  

  BEGIN
    
    OPEN SALOFFTODPT_CUR();
    LOOP
      FETCH SALOFFTODPT_CUR INTO SALOFFTODPT_REC;      
      EXIT WHEN SALOFFTODPT_CUR%NOTFOUND;
    
      IF SALOFFTODPT_CUR%FOUND THEN              
      BEGIN 
        INSERT_LASTUSED(SALOFFTODPT_REC.SALOFFNO, IN_DPTRECNO, C_DPTTOSALOFFNO, IN_OPERATIONTYPE);
      
      EXCEPTION
        WHEN OTHERS THEN
          ROLLBACK;
          FT_PK_ERRORS.LOG_AND_CONTINUE;
      END;                
      END IF;
    END LOOP;
    
    COMMIT;        -- NOTE: PUTTING THE COMMIT HERE MEANS THAT IF AN ERROR OCCURS THEN ALL THE RECORDS BEFORE THE ERROR WILL NOT GET PROCESSED
    CLOSE SALOFFTODPT_CUR;
  EXCEPTION
    WHEN OTHERS THEN
      IF SALOFFTODPT_CUR%ISOPEN THEN
        CLOSE SALOFFTODPT_CUR;
      END IF;
      FT_PK_ERRORS.LOG_AND_STOP();    
  
  END REFLAG_DPTTOSALOFFNO_D;


  /*  DELETES A RECORD FROM HH_TABLE_LASTUSED 
      Changed TV 19Jul16 to only delete a record if all other flags are set to 0.  Need to edit this if
      the number of flags is ever changed*/    
  PROCEDURE DELETE_HH_TABLE_LASTUSED(IN_RECNO1 INTEGER, IN_RECNO2 INTEGER, IN_TABLEFLAG INTEGER, IN_OPERATIONTYPE VARCHAR2, IN_SYSTEMTYPE VARCHAR2 )
  AS
  BEGIN
             -- DELETE FROM HH_TABLE_LASTUSED 
             -- WHERE UNIQUERECNO = IN_RECNO1
             -- AND UNIQUERECNO2  = IN_RECNO2
             -- AND TABLEFLAG     = IN_TABLEFLAG
             -- AND OPERATIONTYPE = IN_OPERATIONTYPE;
              
             MERGE INTO HH_TABLE_LASTUSED HH_LU  
             USING (SELECT IN_RECNO1 UNIQUERECNO , IN_RECNO2 UNIQUERECNO2, IN_TABLEFLAG TABLEFLAG, IN_OPERATIONTYPE OPERATIONTYPE,  SYSDATE LASTUSED FROM DUAL) TMPTAB
             ON (TMPTAB.UNIQUERECNO = HH_LU.UNIQUERECNO
                 AND TMPTAB.UNIQUERECNO2 = HH_LU.UNIQUERECNO2
	               AND TMPTAB.TABLEFLAG = HH_LU.TABLEFLAG
                 )
             WHEN MATCHED THEN 
                UPDATE SET HH_LU.WAITINGFORHH = 0
                DELETE WHERE HH_LU.WAITINGFORBI = 0;
    EXCEPTION
    WHEN OTHERS THEN
      FT_PK_ERRORS.LOG_AND_CONTINUE(); 
            
  END DELETE_HH_TABLE_LASTUSED;
  
  
  /*  SET THIS TO EITHER C, U D BEFORE CALLING REFLAG PROCEDURE AND THE REFLAG WILL USE THIS TO DETERMINE WHAT TO DO
      EG 'C' WILL TREAT ALL REFLAGS AS A CREATE 
  */    
  PROCEDURE SET_GENERICREFLAGACTION(IN_OPERATIONTYPE VARCHAR2)
  AS
  BEGIN
    IF IN_OPERATIONTYPE = C_CREATE           
    OR IN_OPERATIONTYPE = C_UPDATE           
    OR IN_OPERATIONTYPE = C_DELETE            THEN
      C_GENERICREFLAGACTION := IN_OPERATIONTYPE;
    END IF;
  END SET_GENERICREFLAGACTION;
  
  
FUNCTION GETVATFORPRODUCT (IN_PRODUCT IN INTEGER, IN_SALESOFFICE IN INTEGER := -32000) RETURN INTEGER
AS
   OUT_VATRECNO INTEGER := 999;
   OUT_VEARECNO INTEGER;
   OUT_VATLNKRECNO INTEGER;
BEGIN
  
  BEGIN 
     BSDL_PK_VAT.GETBESTVAT( 298, IN_PRODUCT, -32000, IN_SALESOFFICE, OUT_VATRECNO, OUT_VEARECNO, OUT_VATLNKRECNO);
  EXCEPTION
		 WHEN OTHERS THEN OUT_VATRECNO := -1;
 	END;
  RETURN (OUT_VATRECNO);
  
END GETVATFORPRODUCT;
    
 
  
  
END FT_PK_HH ;